import pandas as pd
import datetime as dt
import binance
from collections import deque
from binance.client import Client
from binance.enums import *
from unicorn_binance_websocket_api import BinanceWebSocketApiManager
from binance.exceptions import BinanceAPIException, BinanceOrderException
#from binance.streams import BinanceSocketManager
from binance import ThreadedWebsocketManager
from twisted.internet import reactor
import json
import time
import talib
import numpy as np
import math
from decimal import Decimal
import requests
from datetime import datetime
import matplotlib.pyplot as plt
from matplotlib.pyplot import MultipleLocator
import threading
from IPython.display import clear_output
import nbformat
import re, ast
import random


#2025
api_key = '6F3gbZdwCujetxnxQ9S9hNHAaQUBs4UFVS6Jgvcy9eJQkhb5Fbw4UPK59cfC9HyG'
api_secret = 'Lh0rlZd5yv8CmWGsWI9pTEPtEuVys4tauBdaxVKWmeII1ZsqyR4t78WMikjEdDNa'


directly_close = 0 #1:直接全部平倉
twoSingal_CEUT_buy = 0        #--------給多訊
twoSingal_CEUT_sell = 0        #--------給空訊


re_entry_buy = 0
re_entry_sell = 0
leverage = 50
benefit = 0

filename = '2025_3k_updown.ipynb'

order_USDT = 10 #下單USDT
orig_USDT = 30
record_USDT = 0
buffer_USDT = 0
all_buffer = 1

av_balance = None
mg_balance = None
ur_balance = None
initialMargin = None
wt_balance = None

hold_buy_set = []
hold_sell_set = []
buy_time = ''
sell_time = ''
buy_already = 0
sell_already = 0
rebuy_set = []
resell_set = []
restoploss_set = []


buy_line = 0
sell_line = 0

start_bet = 0
stop_bet = 0
split_flag = 1
kline_update_time = 0.5
conpound_flag = 1
divid_total_money = 10
order_id = 0
#止損

stop_loss_set = []                   #--------stoploss
order_count = 0
stoploss_continue_order = 1
stoploss_thread_flag = 0
contract_balance_buffer = 0
save_config_txt = ''


#-----3k_UT_lonstop----#

longstop_up = 0
longstop_down = 0

#------twosignal-------
targetSingal_buy_high = []
targetSingal_sell_low = []  #雙賣訊低點
twoSignal_last_buy_high_signal = 0
twoSignal_last_sell_low_signal = 0
save_buy_K_low_between_two_signal = []
save_sell_K_high_between_two_signal = []   #雙賣訊中間高點
twoSingal_last_signal = 0 #前一個訊號
twoSignal_05percent_flag = 0 #反手 0.5% flag
keep_targetSignal_flag = 0
buy_low = []
sell_high = []
twoSingal_clean_save_high_low_flag = 1
twoSingal_close_05_sellout = 1.5
twoSingal_middle_high = 0
twoSingal_middle_low = 0

twoSignal_ema5_continue_5k_up = 0
twoSignal_ema5_continue_5k_down = 0

twoSignal_opposite_signal_flag = 0
twoSignal_2percent_flag = 0

twoSignal_3percent_flag = 0

twoSignal_4percent_flag = 0
twoSignal_4percent_profit_high = 0
twoSignal_4percent_profit_low = 0



#---------show_print-------------

show_tax = 0

#---------strategy_flag----------

strategy_25_50_flag = 0
strategy_25_50_continue_flag = 0 #2550 都出完後,拉回是否要重新進場
strategy_10percent = 1


#---------initail variable--------

init = 0
lastprice = 0
t_lastprice = 0

ETH_queue = deque()
Thread_queue = deque()

price = []
quantity =[]
benefit_percent = 0.01
bound_quantity = 0

last_5k_close = 0
now_5k_close = 0
last_5k_open = 0
now_5k_open = 0
last_5k_high = 0
last_5k_low = 0
change_k_temp = 0
change_k_flag = 0 #--------5k flag
time_day = ''


#紅黑K line
red_5k_continue = 0
black_5k_continue = 0

v_asset_usdt = 0
v_asset_usdt_free = 0
v_asset_usdt_locked = 0
v_asset_eth = 0
v_asset_eth_free = 0
v_asset_eth_locked = 0
ordre_check_p = 1
ordre_check_q = 1


#-----------CEUT_P1P------------
Grid_CEUT = 0

check_cross2p1p_flag = 0
check_cross2m1p_flag = 0

ceut_continue = 0
wait2touch_120ma = 0
ceut_shoot_flag = 0

sign_way = 0    #倉位方向
sign_now = -1   #買賣訊號
p1p_stop_sign = 0

first_price = 0
second_price = 0

buy_open_price = 0
sell_open_price = 0

profit_start = 0
Grid_stopProfit_percent = 1 # %

CEUT_buy_count = 0
CEUT_sell_count = 0

Grid_raise_order_flag = 0
Grid_raise_order = 0
Grid_raise_order_percent = 0.2 # KH
Grid_moving_sellout_flag = 0
Grid_moving_sellout_time = 0
Grid_sellout_percent = 7.0#%
Grid_last_order_way = 1
Grid_stoploss_time = 0
Grid_KH_flag = 0
Grid_4percent_flag = 0
Grid_1percent_return_flag = 0
Grid_return_position = []
Grid_final_return_position = 0
Grid_CE_buy_record = 0
Grid_CE_sell_record = 0

Grid_total_sellout_flag = 0
Grid_total_sellout_high = 0.0
Grid_total_sellout_low = 0.0

last_UT_position = 0
last_longStop_position = 0
last_shortStop_position = 0

#--------MACD_Divergence--------

firstPH = 0
secondPH = 0
firstMH = 0
secondMH = 0
firstPH_flag = 0
secondPH_flag = 0


firstPL = 0
secondPL = 0
firstML = 0
secondML = 0

firstPL_flag = 0
secondPL_flag = 0


firstMH_flag = 0
secondMH_flag = 0
firstML_flag = 0
secondML_flag = 0

macd_s_line = 0.95 # MACD second point上下限
macd_f_line = 0.15 # MACD first point上下限

t_fph = ''
t_sph = ''
t_fpl = ''
t_spl = ''
t_fmh = ''
t_smh = ''
t_fml = ''
t_sml = ''

macd_up2zero_flag = 0
macd_down2zero_flag = 0

order_benefit_1p_flag = 0

#--------P1P--------------------

#價位在120上或下
P1P_upper_120ma = 1
P1P_below_120ma = 0

#價位在120 +- 1% 上或下
P1P_above_120ma_p = 0
P1P_under_120ma_p = 0
P1P_above_120ma_m = 0
P1P_under_120ma_m = 0

#price plus or minus 1 percent
P1P_EMA120_5k_p1p = 1823
P1P_EMA120_5k_m1p = 1791

#price plus or minus 2 percent
P2P_EMA120_5k_p1p = 1823
P2P_EMA120_5k_m1p = 1791

#是否己保護結束
P1P_go_return = 0
P1P_go_return_buy = 0
P1P_go_return_sell = 0

P1P_stopProfit_at_120ma = 0 #己進入120 +- 1% 保護
P1P_Boundary_percent = 0.008
P2P_Boundary_percent = 0.0085
P1P_stoploss_flag = 0

#--------Red&Black--------------------

RB_Positive = 0
RB_Negative = 0 

RB_TaxRate = 0.0004
RB_Total_TaxRate = 0
RB_red_continue = 0
RB_black_continue = 0

RB_bound = 1
RB_bound_count = 0
RB_120ma_bound = 1

RB_hrh_count = 0
RB_lrl_count = 0

RB_buy_count = 0
RB_sell_count = 0

#RB_buy_touch_120ma = 1
#RB_sell_touch_120ma = 1

RB_over_x_percent_flag = 0
RB_close_120ma = 2.5

RB_max_loss_percent = 0


#--------Hufferman--------------------

HF_5k_bound = 1.5
HF_15k_bound = 8
HF_stoploss = 15
HF_EMA120_5k_flag = 0
HF_EMA120_15k_flag = 0
HF_EMA120_5k_check_value = 15
HF_EMA120_15k_check_value = 20

HF_last_2_5k_close = 0
HF_last_2_15k_close = 0

HF_last_2_5k_high = 0
HF_last_2_15k_high = 0

HF_last_2_5k_low = 0
HF_last_2_15k_low = 0

buy_5k_already = 0
sell_5k_already = 0

buy_15k_already = 0
sell_15k_already = 0


#-------CCI_Supertrend_SlowStoch_StochRSI--------------

bet_5k = 1
bet_15k = 0

TT_bound = 3

#5K
Csss_5k_CCI = 0
Csss_5k_Supertrend = None
Csss_5k_SlowStoch = None
Csss_5k_StochRSI = None

UT_5k_prev, UT_5k_curr = 0, 0
prev_5k_Supertrend = False,np.nan,np.nan #(None)
Up_EMA_5k_flag, Down_EMA_5k_flag = 0, 0 
EMA5_5k = 0
EMA20_5k = 0
EMA60_5k = 0
EMA120_5k = 1796
EMA169_5k = 0
EMA200_5k = 0
EMA240_5k = 0
EMA_5k_list = []

half_sellout_5k_flag = 0
Buy_st, Sell_st = 0, 0
Dont_buy, Dont_sell = 0, 0





#15k
Csss_15k_CCI = 0
Csss_15k_Supertrend = None
Csss_15k_SlowStoch = None
Csss_15k_StochRSI = None

UT_15k_prev ,UT_15k_curr = 0, 0
prev_15k_Supertrend = False,np.nan,np.nan #(None)
Up_EMA_15k_flag, Down_EMA_15k_flag = 0, 0 
EMA20_15k = 0
EMA60_15k = 0
EMA120_15k = 0
EMA169_15k = 0
EMA200_15k = 0
EMA240_15k = 0
EMA_15k_list = []


limit_BuySell_tp_high, limit_BuySell_tp_low = 0, 0

touch_onetime = 0
touch_UTST_area_flag = 0

ST_5k_stoploss_bound = 2.5
ST_15k_stoploss_bound = 3


start_kill_head = 0
kill_head = 0
stoploss_time = 0
middle_in = 0

record_profit = 0
record_loss = 0
re_buysell_flag = 0
Buy_15k_st, Sell_15k_st = 0, 0

touch_ST = 0
#-------CE_UtBot--------------

ATR_1 = []
ATR_300 = []
ema_300 = []
close_300 = []
buy_sell_set = []


UT_5k_Buy = twoSingal_CEUT_buy
UT_5k_Sell = twoSingal_CEUT_sell
UT_15k_Buy = 0
UT_15k_Sell = 0

CE_5k_Buy = twoSingal_CEUT_buy
CE_5k_Sell = twoSingal_CEUT_sell
CE_15k_Buy = 0
CE_15k_Sell = 0

CE_5k_GreenUp_buy = 0
CE_5k_GreenUp_sell = 0
CE_15k_GreenUp_buy = 0
CE_15k_GreenUp_sell = 0
CE_5k_RedUp_buy = 0
CE_5k_RedUp_sell = 0
CE_15k_RedUp_buy = 0
CE_15k_RedUp_sell = 0

stoploss_sellout_flag = 0
global_longStop = []
global_longStopPrev = []
global_shortStop = []
global_shortStopPrev = []

prev_flag = 0


UT_15_boundary_flag = 0
UT_15_bound = 1

#-----check pd data renew
check_pd_data_last = []
check_bot_5_pd_data_last = []
check_bot_15_pd_data_last = []

check_UT_5_pd_data_last = []
check_UT_15_pd_data_last = []


update_5k_flag = 0
update_15k_flag = 0

update_UT_5k_flag = 0
update_UT_15k_flag = 0

last_15k_close = 0
now_15k_close = 0
last_15k_open = 0
now_15k_open = 0
change_15k_temp = 0

last20_15k_high = []
max20_15k_high = 0
last20_15k_low = []
min20_15k_low = 0


red_15k_continue = 0
black_15k_continue = 0

buy_5k_count = 0
sell_5k_count = 0
buy_5k_count_flag = 0
sell_5k_count_flag = 0

buy_15k_count = 0
sell_15k_count = 0
buy_15k_count_flag = 0
sell_15k_count_flag = 0
order_flag = 0

CE_continue = 1



#加減碼分批出場

sellout_25_50_flag = 0
sellout_25_flag = 0  #--------2550 flag
sellout_50_flag = 0
sellout_percent = 0.01 #分批獲利出場價錢%數
sellout_divid = 5 #出場份數
sellout_time = 2 #分批出場次數
sellout_bound = 25
sellout_area = 25
sellout_bound_const_flag = 0 # 是否將出場區間設為常數,1 = 常數,0 為變數
sellout_unit = 10

#------1m_red_black------------

win_count = 0
lose_count = 0
balance_count = 0

average_hold_buy = 0
average_hold_sell  = 0
buy_benefit = 0
sell_benefit = 0
unrealize_profit_flag = 0


#--------limit sellout--------
limit_flag = 0
high_price = 0
low_price = 0
sellout_price = 0
#-------144___169-------


ma5 = 0
ur_balance = 0


#-------conifg.ini-------
from configparser import ConfigParser
cfg = ConfigParser()
cfg.read('./config.ini',encoding="utf-8")
start_bet = cfg['variable'].getint('start_bet') #執行下單

digi_p = 2 # 下單價 位數
digi_q = 3 # 下單量 位數
receive_windows = 60000 # server回傳間格

coin_symbol = 'ETHUSDT'
marketprice = 'https://api.binance.com/api/v1/ticker/24hr?symbol='+ coin_symbol



symbol = 'ETHUSDT'
n = 600

#5m 15m
s = str((n+1)*5)
start_str = s+'minutes ago UTC'
interval_data ='5m'

#1hours
h = str((n+1)*15)
start_str_1h = h+'minutes ago UTC'
interval_data_1h ='15m'

pd.set_option('display.max_rows', 50)

def config_reload():
    global start_bet, CEUT_sell_count, CEUT_buy_count, Grid_raise_order
    global hold_buy_set, hold_sell_set, stop_loss_set, Grid_moving_sellout_flag
    global contract_balance_buffer, record_USDT, order_USDT, order_id,buffer_USDT
    global Grid_sellout_percent, divid_total_money, Grid_4percent_flag
    global Grid_1percent_return_flag, Grid_final_return_position, Grid_return_position
    global Grid_total_sellout_flag, Grid_total_sellout_high, Grid_total_sellout_low
    global targetSingal_buy_high, targetSingal_sell_low
    global save_buy_K_low_between_two_signal, save_sell_K_high_between_two_signal
    global twoSingal_last_signal, twoSignal_05percent_flag
    global buy_low, sell_high, black_5k_continue, red_5k_continue
    global twoSignal_4percent_flag, twoSignal_4percent_profit_high, twoSignal_4percent_profit_low
    global twoSignal_3percent_flag, twoSignal_ema5_continue_5k_up, twoSignal_ema5_continue_5k_down
    global twoSignal_opposite_signal_flag, twoSignal_2percent_flag,twoSignal_last_buy_high_signal, twoSignal_last_sell_low_signal
    global longstop_up,longstop_down
    
    cfg.read('./config.ini',encoding="utf-8")
    start_bet = cfg['variable'].getint('start_bet') #執行下單

    order_id = cfg['variable'].getint('order_id')
    order_USDT = cfg['variable'].getfloat('order_USDT')
    record_USDT = cfg['variable'].getfloat('record_USDT')
    buffer_USDT = cfg['variable'].getfloat('buffer_USDT')
    divid_total_money = cfg['variable'].getint('divid_total_money')
    CEUT_buy_count = cfg['variable'].getint('CEUT_buy_count')
    CEUT_sell_count = cfg['variable'].getint('CEUT_sell_count')
    longstop_up = cfg['variable'].getint('longstop_up')
    longstop_down = cfg['variable'].getint('longstop_down')
    red_5k_continue = cfg['variable'].getint('red_5k_continue')
    black_5k_continue = cfg['variable'].getint('black_5k_continue')
    Grid_4percent_flag = cfg['variable'].getint('Grid_4percent_flag')
    Grid_sellout_percent = cfg['variable'].getfloat('Grid_sellout_percent')
    Grid_last_order_way = cfg['variable'].getint('Grid_last_order_way')
    Grid_raise_order = cfg['variable'].getint('Grid_raise_order')
    Grid_1percent_return_flag = cfg['variable'].getint('Grid_1percent_return_flag')
    Grid_final_return_position = cfg['variable'].getfloat('Grid_final_return_position')
    Grid_total_sellout_flag = cfg['variable'].getint('Grid_total_sellout_flag')
    Grid_total_sellout_high = cfg['variable'].getfloat('Grid_total_sellout_high')
    Grid_total_sellout_low = cfg['variable'].getfloat('Grid_total_sellout_low')
    twoSignal_4percent_flag = cfg['variable'].getint('twoSignal_4percent_flag')
    twoSignal_4percent_profit_high = cfg['variable'].getfloat('twoSignal_4percent_profit_high')
    twoSignal_4percent_profit_low = cfg['variable'].getfloat('twoSignal_4percent_profit_low')
    twoSignal_3percent_flag = cfg['variable'].getint('twoSignal_3percent_flag')
    twoSignal_ema5_continue_5k_up = cfg['variable'].getint('twoSignal_ema5_continue_5k_up')
    twoSignal_ema5_continue_5k_down = cfg['variable'].getint('twoSignal_ema5_continue_5k_down')
    twoSignal_opposite_signal_flag = cfg['variable'].getint('twoSignal_opposite_signal_flag')
    twoSignal_2percent_flag = cfg['variable'].getint('twoSignal_2percent_flag')
    twoSingal_last_signal = cfg['variable'].getint('twoSingal_last_signal')
    twoSignal_05percent_flag = cfg['variable'].getint('twoSignal_05percent_flag')
    twoSignal_last_buy_high_signal = cfg['variable'].getfloat('twoSignal_last_buy_high_signal')
    twoSignal_last_sell_low_signal = cfg['variable'].getfloat('twoSignal_last_sell_low_signal')
    targetSingal_buy_high = config_read_list('targetSingal_buy_high')
    targetSingal_sell_low = config_read_list('targetSingal_sell_low')
    save_buy_K_low_between_two_signal = config_read_list('save_buy_K_low_between_two_signal')
    save_sell_K_high_between_two_signal = config_read_list('save_sell_K_high_between_two_signal')
    buy_low = config_read_list('buy_low')
    sell_high = config_read_list('sell_high')
   
    if cfg['variable'].getfloat('Grid_return_position') != 0:
        Grid_return_position.append(cfg['variable'].getfloat('Grid_return_position'))
    if cfg['variable'].getfloat('hold_buy_set') != 0:
        hold_buy_set.append(cfg['variable'].getfloat('hold_buy_set'))
    if cfg['variable'].getfloat('hold_sell_set') != 0:
        hold_sell_set.append(cfg['variable'].getfloat('hold_sell_set'))
    if cfg['variable'].getfloat('stop_loss_set') != 0:
        stop_loss_set.append(cfg['variable'].getfloat('stop_loss_set'))
    Grid_moving_sellout_flag = cfg['variable'].getint('Grid_moving_sellout_flag')
    contract_balance_buffer = cfg['variable'].getint('contract_balance_buffer')
    
    if init == 0:
        print('start_bet = ',start_bet)
        print('order_id = ',order_id)
        print('order_USDT = ',order_USDT)
        print('record_USDT = ',record_USDT)
        print('buffer_USDT = ',buffer_USDT)
        print('divid_total_money = ',divid_total_money)
        print('CEUT_buy_count = ',CEUT_buy_count)
        print('CEUT_sell_count = ',CEUT_sell_count)
        print('longstop_up = ',longstop_up)
        print('longstop_down = ',longstop_down)
        print('red_5k_continue = ',red_5k_continue)
        print('black_5k_continue = ',black_5k_continue)
        print('Grid_4percent_flag = ',Grid_4percent_flag)
        print('Grid_raise_order = ',Grid_raise_order)
        print('Grid_last_order_way = ',Grid_last_order_way)
        print('Grid_sellout_percent = ',Grid_sellout_percent)
        print('Grid_1percent_return_flag = ',Grid_1percent_return_flag)
        print('Grid_final_return_position = ',Grid_final_return_position)
        print('Grid_return_position = ',Grid_return_position)
        print('Grid_total_sellout_flag = ',Grid_total_sellout_flag)
        print('Grid_total_sellout_high = ',Grid_total_sellout_high)
        print('Grid_total_sellout_low = ',Grid_total_sellout_low)
        print('twoSignal_4percent_flag = ',twoSignal_4percent_flag)
        print('twoSignal_4percent_profit_high = ',twoSignal_4percent_profit_high)
        print('twoSignal_4percent_profit_low = ',twoSignal_4percent_profit_low)
        print('twoSignal_3percent_flag = ',twoSignal_3percent_flag)
        print('twoSignal_ema5_continue_5k_up = ',twoSignal_ema5_continue_5k_up)
        print('twoSignal_ema5_continue_5k_down = ',twoSignal_ema5_continue_5k_down)
        print('twoSignal_opposite_signal_flag = ',twoSignal_opposite_signal_flag)
        print('twoSignal_2percent_flag = ',twoSignal_2percent_flag)
        print('twoSingal_last_signal = ',twoSingal_last_signal)
        print('twoSignal_05percent_flag = ',twoSignal_05percent_flag)
        print('twoSignal_last_buy_high_signal = ',twoSignal_last_buy_high_signal)
        print('twoSignal_last_sell_low_signal = ',twoSignal_last_sell_low_signal)
        print('targetSingal_buy_high = ',targetSingal_buy_high)
        print('targetSingal_sell_low = ',targetSingal_sell_low)
        print('save_buy_K_low_between_two_signal = ',save_buy_K_low_between_two_signal)
        print('save_sell_K_high_between_two_signal = ',save_sell_K_high_between_two_signal)
        print('buy_low = ',buy_low)
        print('sell_high = ',sell_high)
        print('hold_buy_set = ',hold_buy_set)
        print('hold_sell_set = ',hold_sell_set)
        print('stop_loss_set = ',stop_loss_set)
        print('Grid_moving_sellout_flag = ',Grid_moving_sellout_flag)
        print('contract_balance_buffer = ',contract_balance_buffer)


def config_read_list(s):

    cfg.read('./config.ini',encoding="utf-8")
    raw = cfg["variable"][s]
    s2 = re.sub(r'np\.float64\(\s*([-\d\.eE+]+)\s*\)', r'\1', raw)
    lst = ast.literal_eval(s2)
    values = [float(x) for x in lst]

    return values
        
def write_to_config(filename, content):
    
    try:
        with open(filename, 'w') as file:
            file.write(content)
        print(f"變數己寫入到{filename}檔案中")
    except Exception as e:
        print(f"存檔出現error: {str(e)}")
        
        
def save_context():
    
    global save_config_txt
    
    buy_set = 0
    sell_set = 0
    stoploss_set = 0
    grid_return_position_set = 0
    
    if len(hold_buy_set) > 0:
        buy_set = hold_buy_set[0]

    if len(hold_sell_set) > 0:
        sell_set = hold_sell_set[0]
        
    if len(stop_loss_set) > 0:
        stoploss_set = stop_loss_set[0]
        
    if len(Grid_return_position) > 0:
        grid_return_position_set = Grid_return_position[len(Grid_return_position) - 1]
    
    save_config_txt = f"[variable]\n" \
                f"#------------------------------------------>執行下單:1?0\n" \
                f"start_bet = {start_bet}\n\n" \
                f"#停損單id\n" \
                f"order_id = {order_id}\n\n" \
                f"#------------------------------------------>進場資金\n" \
                f"order_USDT = {order_USDT}\n\n" \
                f"#------------------------------------------>目前最高資金\n" \
                f"record_USDT = {record_USDT}\n\n" \
                f"#------------------------------------------>目前保留資金\n" \
                f"buffer_USDT = {buffer_USDT}\n\n" \
                f"#------------------------------------------>資金分割比例\n" \
                f"divid_total_money = {divid_total_money}\n\n" \
                f"#買單位置\n" \
                f"hold_buy_set = {buy_set}\n\n" \
                f"#賣單位置\n" \
                f"hold_sell_set = {sell_set}\n\n" \
                f"#停損單位置\n" \
                f"stop_loss_set = {stoploss_set}\n\n" \
                f"#買單連續訊號次數\n" \
                f"CEUT_buy_count = {CEUT_buy_count}\n\n" \
                f"#賣單連續訊號次數\n" \
                f"CEUT_sell_count = {CEUT_sell_count}\n\n" \
                f"#收K在綠之上連續次數\n" \
                f"longstop_up = {longstop_up}\n\n" \
                f"#收K在綠之下連續次數\n" \
                f"longstop_down = {longstop_down}\n\n" \
                f"#紅K連續次數\n" \
                f"red_5k_continue = {red_5k_continue}\n\n" \
                f"#黑K連續次數\n" \
                f"black_5k_continue = {black_5k_continue}\n\n" \
                f"#進場後拉回UT狀態:0(未逹):1(己達)\n" \
                f"Grid_4percent_flag = {Grid_4percent_flag}\n\n" \
                f"#目前反手相對位置\n" \
                f"Grid_return_position = {grid_return_position_set}\n\n" \
                f"#己確認反手位置\n" \
                f"Grid_final_return_position = {Grid_final_return_position}\n\n" \
                f"#反手滿足點:0(未逹):1(己達):2(己反手)\n" \
                f"Grid_1percent_return_flag = {Grid_1percent_return_flag}\n\n" \
                f"#7.5%保護判斷:0(未保護)?1(己保護)\n" \
                f"Grid_total_sellout_flag = {Grid_total_sellout_flag}\n\n" \
                f"#保護高點\n" \
                f"Grid_total_sellout_high = {Grid_total_sellout_high}\n\n" \
                f"#保護低點\n" \
                f"Grid_total_sellout_low = {Grid_total_sellout_low}\n\n" \
                f"#加碼次數\n" \
                f"Grid_raise_order = {Grid_raise_order}\n\n" \
                f"#直接出場%數\n" \
                f"Grid_sellout_percent = {Grid_sellout_percent}\n\n" \
                f"#前次進場訊號\n" \
                f"Grid_last_order_way = {Grid_last_order_way}\n\n" \
                f"#最高資金差額\n" \
                f"contract_balance_buffer = {contract_balance_buffer}\n\n" \
                f"#目前網格移動位置\n" \
                f"Grid_moving_sellout_flag = {Grid_moving_sellout_flag}\n\n" \
                f"#4%保護判斷:0(未保護)?1(己保護)\n" \
                f"twoSignal_4percent_flag = {twoSignal_4percent_flag}\n\n" \
                f"#4%保護高點\n" \
                f"twoSignal_4percent_profit_high = {twoSignal_4percent_profit_high}\n\n" \
                f"#4%保護低點\n" \
                f"twoSignal_4percent_profit_low = {twoSignal_4percent_profit_low}\n\n" \
                f"#3%保護判斷:0(未保護)?1(己保護)\n" \
                f"twoSignal_3percent_flag = {twoSignal_3percent_flag}\n\n" \
                f"#站上ema(5)連續次數\n" \
                f"twoSignal_ema5_continue_5k_up = {twoSignal_ema5_continue_5k_up}\n\n" \
                f"#跌破ema(5)連續次數\n" \
                f"twoSignal_ema5_continue_5k_down = {twoSignal_ema5_continue_5k_down}\n\n" \
                f"#反向訊號flag\n" \
                f"twoSignal_opposite_signal_flag = {twoSignal_opposite_signal_flag}\n\n" \
                f"#2%保護判斷:0(未保護)?1(己保護)\n" \
                f"twoSignal_2percent_flag = {twoSignal_2percent_flag}\n\n" \
                f"#雙訊號前一個雙訊號方向\n" \
                f"twoSingal_last_signal = {twoSingal_last_signal}\n\n" \
                f"#雙訊號0.5% flag\n" \
                f"twoSignal_05percent_flag = {twoSignal_05percent_flag}\n\n" \
                f"#雙多訊號前高點\n" \
                f"twoSignal_last_buy_high_signal = {twoSignal_last_buy_high_signal}\n\n" \
                f"#雙空訊號前低點\n" \
                f"twoSignal_last_sell_low_signal = {twoSignal_last_sell_low_signal}\n\n" \
                f"#雙多訊號高點\n" \
                f"targetSingal_buy_high = {targetSingal_buy_high}\n\n" \
                f"#雙空訊號低點\n" \
                f"targetSingal_sell_low = {targetSingal_sell_low}\n\n" \
                f"#雙多訊號之間低點\n" \
                f"save_buy_K_low_between_two_signal = {save_buy_K_low_between_two_signal}\n\n" \
                f"#雙空訊號之間高點\n" \
                f"save_sell_K_high_between_two_signal = {save_sell_K_high_between_two_signal}\n\n" \
                f"#多單單次進場之間低點\n" \
                f"buy_low = {buy_low}\n\n" \
                f"#空單單次進場之間高點\n" \
                f"sell_high = {sell_high}\n\n"

    
kline_close = [] 
kline_high = []
kline_low = []
df22_close = []


def kline_5m():
    
    global last_5k_close, now_5k_close, black_5k_continue, red_5k_continue, last_5k_open, now_5k_open, change_k_flag, change_k_temp
    global check_pd_data_last, HF_last_2_5k_close, HF_last_2_5k_high, HF_last_2_5k_low
    global last_5k_high, last_5k_low, kline_close, kline_high, kline_low, df22_close
    global buy_low, sell_high, twoSingal_clean_save_high_low_flag

    check_pd_data_renew = []
    kline_close = []
    kline_high = []
    kline_low = []

    
   
        
    
    
    try:

        symbol = coin_symbol
        start_str = '605minutes ago UTC'
        interval_data ='5m'
        
        pd_data = pd.DataFrame(client.futures_historical_klines(symbol = symbol , start_str = start_str, limit = 1000, interval = interval_data))
        pd_data.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'qav','num_trades',
                     'taker_base_vol', 'taker_quote_vol', 'is_best_match']

        pd_data['open_date_time'] = [dt.datetime.fromtimestamp(x / 1000) for x in pd_data.open_time]
        pd_data['symbol'] = symbol
        pd_data = pd_data[['symbol', 'open_date_time', 'open', 'high', 'low', 'close', 'volume','num_trades','taker_base_vol',
               'taker_quote_vol']]

        
        df = pd_data.set_index('open_date_time')

        df['close'] = df['close'].astype(float)

        df = df['close']

        
        dfl = df.resample('5min').agg({

            "close":"last"
        })
        
        df_o = pd_data.set_index('open_date_time')

        df_o['open'] = df_o['open'].astype(float)

        df_o = df_o['open']

        dfl_o = df_o.resample('5min').agg({

            "open":"last"
        })
        
        df_h = pd_data.set_index('open_date_time')

        df_h['high'] = df_h['high'].astype(float)

        df_h = df_h['high']

        dfl_h = df_h.resample('5min').agg({

            "high":"last"
        })
        
        df_l = pd_data.set_index('open_date_time')

        df_l['low'] = df_l['low'].astype(float)

        df_l = df_l['low']

        dfl_l = df_l.resample('5min').agg({

            "low":"last"
        })

        
    
        last_5k_open = dfl_o['open'].iloc[-2]
        last_5k_high = dfl_h['high'].iloc[-2]
        last_5k_low = dfl_l['low'].iloc[-2]
        now_5k_open = dfl_o['open'].iloc[-1]
        
        
        HF_last_2_5k_close = dfl['close'].iloc[-3]
        HF_last_2_5k_high = dfl_h['high'].iloc[-3]
        HF_last_2_5k_low = dfl_l['low'].iloc[-3]
        
        last_5k_close = dfl['close'].iloc[-2]
        now_5k_close = dfl['close'].iloc[-1]

        for i in range (1,120):
            kline_close.append(dfl['close'].iloc[i])
            kline_high.append(dfl_h['high'].iloc[i])
            kline_low.append(dfl_l['low'].iloc[i])


        
        
        #print('change_k_temp:',change_k_temp,now_time())
        #print('last_5k_close:',last_5k_close,now_time())
#        if change_k_temp != last_5k_close:
#            if change_k_temp != 0:
#                change_k_flag = 1
#            change_k_temp = last_5k_close
            #print('change_k_temp:',change_k_temp,now_time())
            #print('last_5k_close:',last_5k_close,now_time())
            
            

        #print('前一根收---->',dfl_o['open'].iloc[0])
        #print('現在收------>',dfl_o['open'].iloc[1])

    except Exception as e:
        if str(e) == 'index 120 is out of bounds for axis 0 with size 120':
            pass
        else:
            print(f'(5m)錯誤訊息: {e}')
            time.sleep(0.5)
        pass


        
    for x in range (3-1,6-1):
        check_pd_data_renew.append(pd_data['close'].iloc[len(pd_data['close'])-x])

    if len(check_pd_data_last) == 0:
        check_pd_data_last = check_pd_data_renew
#        print('check_pd_data_last',check_pd_data_last,now_time())

        print('(Kline)Data空,己更新',now_time())

        '''
        df22_close = pd_data['close'].iloc[-23:-1].tolist()
    
        print('sell_high:' , sell_high)
        print('buy_low :' , buy_low)
        sell_high.append (dfl_h['high'].iloc[-2])
        print('sell_high:' , sell_high)
        buy_low.append(dfl_l['low'].iloc[-2])
        print('buy_low :' , buy_low)
        '''
        return 0
    else:
        
        if check_pd_data_last == check_pd_data_renew :
#            print('check_pd_data_last',check_pd_data_last,now_time())
#            print('check_pd_data_renew',check_pd_data_renew,now_time())
            print('(Kline)沒更新,重抓',now_time())
            return 1
        else:
#            print('check_pd_data_last',check_pd_data_last,now_time())
#            print('check_pd_data_renew',check_pd_data_renew,now_time())
            check_pd_data_last = check_pd_data_renew
#            last_5k_close = float(check_pd_data_renew[0])
#            HF_last_2_5k_close = float(check_pd_data_renew[1])
            
#            print('(Kline)前一根五分K己更新',last_5k_close,now_time())
#            print('(Kline)前兩根五分K己更新',HF_last_2_5k_close,now_time())
            print('(Kline)己更新',now_time())

            if twoSingal_clean_save_high_low_flag == 1: 
#                print('twoSingal_clean_save_high_low_flag 為: ',twoSingal_clean_save_high_low_flag)
                print('暫存高低點')
                if init == 1:
                    twoSingal_clean_save_high_low_flag = 0
#                    print('twoSingal_clean_save_high_low_flag 改為: ',twoSingal_clean_save_high_low_flag)
        
            elif twoSingal_clean_save_high_low_flag == 0: 
        
                if len(buy_low) != 0 and len(sell_high) != 0:
                    if init == 1:
                        sell_high.pop() 
                        buy_low.pop()
#                        print('twoSingal_clean_save_high_low_flag 為: ',twoSingal_clean_save_high_low_flag)
                        print('刪除暫存高低點')
            
            df22_close = pd_data['close'].iloc[-23:-1].tolist()
#            print('test_pd_data_last',df22_close,now_time())
            sell_high.append (dfl_h['high'].iloc[-2])
#            print('sell_high:' , sell_high)
            buy_low.append(dfl_l['low'].iloc[-2])
#            print('buy_low :' , buy_low)
            
            return 0
    
    
def kline_bot_5m(n):
    
    global last_5k_close, now_5k_close, black_5k_continue, red_5k_continue, last_5k_open, now_5k_open, change_k_flag
    global pd_data, check_bot_5_pd_data_last
    
    check_pd_data_renew = []
    
    try:

        symbol = coin_symbol
        s = str((n+1)*5)
        start_str = s+'minutes ago UTC'
        interval_data ='5m'
        
        pd_data = pd.DataFrame(client.futures_historical_klines(symbol = symbol , start_str = start_str, limit = 1000, interval = interval_data))
        pd_data.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'qav','num_trades',
                     'taker_base_vol', 'taker_quote_vol', 'is_best_match']

    except Exception as e:
        if str(e) == 'index 120 is out of bounds for axis 0 with size 120':
            pass
        else:
            print(f'(5m)錯誤訊息: {e}')
            time.sleep(0.5)
        pass
    
    for x in range (3-1,6-1):
        check_pd_data_renew.append(pd_data['close'].iloc[len(pd_data['close'])-x])
    
    
    if len(check_bot_5_pd_data_last) == 0:
        check_bot_5_pd_data_last = check_pd_data_renew
        print('(CE_5)Data空,己更新',now_time())

    
        return 0
#        print('check_bot_5_pd_data_last',check_bot_5_pd_data_last)
#        print('check_pd_data_renew',check_pd_data_renew)
    else:
        
        if check_bot_5_pd_data_last == check_pd_data_renew :
#            print('check_bot_5_pd_data_last',check_bot_5_pd_data_last)
#            print('check_pd_data_renew',check_pd_data_renew)
            print('(CE_5)5k,沒更新,重抓',now_time())
            return 1
        else:
#            print('check_bot_5_pd_data_last',check_bot_5_pd_data_last)
#            print('check_pd_data_renew',check_pd_data_renew)
            check_bot_5_pd_data_last = check_pd_data_renew
            print('(CE_5)5k,己更新',now_time())
            return 0
        

def kline_bot_15m(n):
    
    global last_15k_close, now_15k_close, black_5k_continue, red_5k_continue, last_15k_open, now_15k_open, change_k_flag, change_15k_temp
    global check_bot_15_pd_data_last
    global last20_15k_high, last20_15k_low, max20_15k_high, min20_15k_low
    global HF_last_2_15k_close, HF_last_2_15k_high, HF_last_2_15k_low
    
    check_pd_data_renew = []
    last20_15k_high = []
    last20_15k_low = []
    
    try:

        symbol = coin_symbol
        s = str((n+1)*15)
        start_str = s+'minutes ago UTC'
        interval_data ='15m'
        
        pd_data = pd.DataFrame(client.futures_historical_klines(symbol = symbol , start_str = start_str, limit = 1000, interval = interval_data))
        pd_data.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'qav','num_trades',
                     'taker_base_vol', 'taker_quote_vol', 'is_best_match']

        pd_data['open_date_time'] = [dt.datetime.fromtimestamp(x / 1000) for x in pd_data.open_time]
        pd_data['symbol'] = symbol
        pd_data = pd_data[['symbol', 'open_date_time', 'open', 'high', 'low', 'close', 'volume','num_trades','taker_base_vol',
               'taker_quote_vol']]
        
        df = pd_data.set_index('open_date_time')

        df['close'] = df['close'].astype(float)

        df = df['close']

        dfl = df.resample('15min').agg({

            "close":"last"
        })

        df_o = pd_data.set_index('open_date_time')

        df_o['open'] = df_o['open'].astype(float)

        df_o = df_o['open']

        dfl_o = df_o.resample('15min').agg({

            "open":"last"
        })
        
        df_h = pd_data.set_index('open_date_time')

        df_h['high'] = df_h['high'].astype(float)

        df_h = df_h['high']

        dfl_h = df_h.resample('15min').agg({

            "high":"last"
        })
        
        df_l = pd_data.set_index('open_date_time')

        df_l['low'] = df_l['low'].astype(float)

        df_l = df_l['low']

        dfl_l = df_l.resample('15min').agg({

            "low":"last"
        })

        
#        598 599 600
#        print(len(dfl_o['open']))
#        print(dfl['open'].iloc[599])
#        print(dfl['open'].iloc[len(dfl_o['open'])-2])
        last_15k_open = dfl_o['open'].iloc[-2]
        now_15k_open = dfl_o['open'].iloc[-1]

#        print(len(dfl_o['close']))
#        print(dfl['close'].iloc[len(dfl_o['close'])-2])
        HF_last_2_15k_close = dfl['close'].iloc[-3]
        HF_last_2_15k_high = dfl_h['high'].iloc[-3]
        HF_last_2_15k_low = dfl_l['low'].iloc[-3]
        
        
        last_15k_close = dfl['close'].iloc[-2]
        now_15k_close = dfl['close'].iloc[-1]

    except Exception as e:
        if str(e) == 'index 120 is out of bounds for axis 0 with size 120':
            pass
        else:
            print(f'(15m)錯誤訊息: {e}')
            time.sleep(1)
        pass
    
    for x in range (len(pd_data['high']) - 23,len(pd_data['high'])):    
        last20_15k_high.append(pd_data['high'].iloc[x])
        last20_15k_low.append(pd_data['low'].iloc[x])
        
#    print('last20_15k_high:',last20_15k_high)
#    print('last20_15k_low:',last20_15k_low)

    max20_15k_high = float(max(last20_15k_high))
    min20_15k_low = float(min(last20_15k_low))
    
    print('               ',end = '')
    print('max20_15k_high:',max20_15k_high)
    print('               ',end = '')
    print('min20_15k_low:',min20_15k_low)
    
    for x in range (3,6):
        check_pd_data_renew.append(pd_data['close'].iloc[len(pd_data['close'])-x])
    
    
    if len(check_bot_15_pd_data_last) == 0:
        check_bot_15_pd_data_last = check_pd_data_renew
        print('               ',end = '')
        print('(CE_15)Data空,己更新',now_time())
        return 0
    else:
        
        if check_bot_15_pd_data_last == check_pd_data_renew :

            print('               ',end = '')
            print('(CE_15)15k,沒更新,重抓',now_time())
            return 1
        else:
#            last_15k_close = pd_data['close'].iloc[len(pd_data['close'])-1]
            last_15k_close = dfl['close'].iloc[599]
            check_bot_15_pd_data_last = check_pd_data_renew
            
            print('               ',end = '')
            print('(CE_15)15k,己更新',now_time())
            print('               ',end = '')
            print('15k,前一根收盤位置在:',last_15k_close)
            return 0
        
        
def kline_UT_5m(n):
    
    global UT_5_pd_data, check_UT_5_pd_data_last, update_UT_5k_flag
    
    check_UT_pd_data_renew = []
    
    try:

        symbol = coin_symbol
        s = str((n+1)*5)
        start_str = s+'minutes ago UTC'
        interval_data ='5m'
        
        UT_5_pd_data = pd.DataFrame(client.futures_historical_klines(symbol = symbol , start_str = start_str, limit = 1000, interval = interval_data))
        UT_5_pd_data.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'qav','num_trades',
                     'taker_base_vol', 'taker_quote_vol', 'is_best_match']

    
        for x in range (3-1,6-1):
            check_UT_pd_data_renew.append(UT_5_pd_data['close'].iloc[len(UT_5_pd_data['close'])-x])

#        print('check_UT_5_pd_data_last:',check_UT_5_pd_data_last)

        if len(check_UT_5_pd_data_last) == 0:
            check_UT_5_pd_data_last = check_UT_pd_data_renew
#            print('(UT_5)Data空,己更新',now_time())
            update_UT_5k_flag = 1
#            print('check_UT_5_pd_data_last',check_UT_5_pd_data_last)
#            print('check_UT_5_pd_data_renew',check_UT_pd_data_renew)
            return 0

        else:

            if check_UT_5_pd_data_last == check_UT_pd_data_renew :
#                print('check_UT_5_pd_data_last:',check_UT_5_pd_data_last)
#                print('check_UT_5_pd_data_renew:',check_UT_pd_data_renew)
#                print('(UT_5)5k,沒更新,重抓',now_time())
                return 1
            else:
#                print('check_UT_5_pd_data_last:',check_UT_5_pd_data_last)
#                print('check_UT_5_pd_data_renew:',check_UT_pd_data_renew)
                check_UT_5_pd_data_last = check_UT_pd_data_renew
                update_UT_5k_flag = 1
#                print('(UT_5)5k,己更新',now_time())
                return 0
        
    except Exception as e:
        if str(e) == 'index 120 is out of bounds for axis 0 with size 120':
            pass
        else:
            print(f'(UT_5m)錯誤訊息: {e}')
            time.sleep(0.5)
        pass
    

def kline_UT_15m(n):
    
    global UT_15_pd_data, check_UT_15_pd_data_last, update_UT_15k_flag
    
    check_UT_pd_data_renew = []
    
    try:

        symbol = coin_symbol
        s = str((n+1)*15)
        start_str = s+'minutes ago UTC'
        interval_data ='15m'
        
        UT_15_pd_data = pd.DataFrame(client.futures_historical_klines(symbol = symbol , start_str = start_str, limit = 1000, interval = interval_data))
        UT_15_pd_data.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'qav','num_trades',
                     'taker_base_vol', 'taker_quote_vol', 'is_best_match']

    
    
        for x in range (3-1,6-1):
            check_UT_pd_data_renew.append(UT_15_pd_data['close'].iloc[len(UT_15_pd_data['close'])-x])

#        print('check_UT_15_pd_data_last:',check_UT_15_pd_data_last)

        if len(check_UT_15_pd_data_last) == 0:
            check_UT_15_pd_data_last = check_UT_pd_data_renew
#            print('(UT_15)Data空,己更新',now_time())
            update_UT_15k_flag = 1
#            print('check_UT_15_pd_data_last:',check_UT_15_pd_data_last)
#            print('check_UT_15_pd_data_renew:',check_UT_pd_data_renew)
            return 0

        else:

            if check_UT_15_pd_data_last == check_UT_pd_data_renew :
#                print('check_UT_15_pd_data_last:',check_UT_15_pd_data_last)
#                print('check_UT_15_pd_data_renew:',check_UT_pd_data_renew)
#                print('(UT_15)15k,沒更新,重抓',now_time())
                return 1
            else:
#                print('check_UT_15_pd_data_last:',check_UT_15_pd_data_last)
#                print('check_UT_15_pd_data_renew:',check_UT_pd_data_renew)
                check_UT_15_pd_data_last = check_UT_pd_data_renew
                update_UT_15k_flag = 1
#                print('(UT_15)15k,己更新',now_time())
                return 0
            
    except Exception as e:
        if str(e) == 'index 120 is out of bounds for axis 0 with size 120':
            pass
        else:
            print(f'(UT_15m)錯誤訊息: {e}')
            time.sleep(0.5)
        pass
        

    
def now_time():
    global  time_day
    
    dt_n = datetime.now()
    time_day = dt_n.strftime("%A")
    
    return dt_n.strftime("%m/%d %H:%M:%S") 


def check_red_black_kline_continue_status(k):
    global red_5k_continue, black_5k_continue
    global red_15k_continue, black_15k_continue
    
    if k == 5:
        if last_5k_close - last_5k_open > 0:
            red_5k_continue = red_5k_continue + 1
            black_5k_continue = 0
            #id_line_way_check()

        elif last_5k_close - last_5k_open < 0:
            black_5k_continue = black_5k_continue + 1
            red_5k_continue = 0
            #id_line_way_check()

        if black_5k_continue == 0 and red_5k_continue == 0:
            if last_5k_close - last_5k_open > 0:
                red_5k_continue = red_5k_continue + 1

            elif last_5k_close - last_5k_open < 0:
                black_5k_continue = black_5k_continue + 1


        if red_5k_continue > 0:
            print('5k目前連續',red_5k_continue,'根紅K')
        if black_5k_continue > 0:
            print('5k目前連續',black_5k_continue,'根黑K')
        if black_5k_continue == 0 and red_5k_continue == 0:
            print('5k目前剛進入判斷')
            
    elif k == 15:
        
#        print('last_15k_close:',last_15k_close)
#        print('last_15k_open:',last_15k_open)
        
        if last_15k_close - last_15k_open > 0:
            red_15k_continue = red_15k_continue + 1
            black_15k_continue = 0
            #id_line_way_check()

        elif last_15k_close - last_15k_open < 0:
            black_15k_continue = black_15k_continue + 1
            red_15k_continue = 0
            #id_line_way_check()

        if black_15k_continue == 0 and red_15k_continue == 0:
            if last_15k_close - last_15k_open > 0:
                red_15k_continue = red_15k_continue + 1

            elif last_15k_close - last_15k_open < 0:
                black_15k_continue = black_15k_continue + 1


        if red_15k_continue > 0:
            print('               ',end = '')
            print('15k目前連續',red_15k_continue,'根紅K')
        if black_15k_continue > 0:
            print('               ',end = '')
            print('15k目前連續',black_15k_continue,'根黑K')
        if black_15k_continue == 0 and red_15k_continue == 0:
            print('               ',end = '')
            print('15k目前剛進入判斷')
        
        
        
def binance_get_order(client,order_id,types): 
    
    #print('---->',order_id)
    
    #'price':'2140'
    #'origQty': '0.00521000'
    #'executedQty': '0.00521000'
    #'cummulativeQuoteQty': '11.41245290'
    #'status': 'FILLED',

    print (types,'This ID ',order_id,'is',client.get_order(symbol = coin_symbol ,orderId = order_id)[types])
    
    return client.get_order(symbol = coin_symbol ,orderId = order_id)[types]    
            

def binance_cancel_limit_order(client,order_id):
    
    print('準備清單,ID:',order_id)
    
    try:
        cancel = client.futures_cancel_order(symbol= coin_symbol,orderId = order_id)
#        cancel = client.futures_cancel_all_open_orders(symbol= coin_symbol)
        
        
    except Exception as e:
        if str(e) == 'APIError(code=-2011): Unknown order sent.':
            return 0

        print(f'錯誤訊息: {e}')
        
    else:
        
        print('清單成功,現在時間:',now_time())    



def binance_cancel_all_futures_order(client):
    
    print('清除所有委託單')
    
    try:
        cancel = client.futures_cancel_all_open_orders(symbol=symbol)         
        
    except Exception as e:
        if str(e) == 'APIError(code=-2011): Unknown order sent.':
            return 0

        print(f'錯誤訊息: {e}')
        
    else:
        
        print('所有委託單,清單成功,現在時間:',now_time())

        
    
def binance_get_account_symbol_coin_mount(client):
    
    global v_asset_usdt ,v_asset_usdt_free ,v_asset_usdt_locked ,v_asset_eth ,v_asset_eth_free ,v_asset_eth_locked
    
    
    balance = client.get_asset_balance(asset='USDT')
    v_asset_usdt = client.get_asset_balance(asset='USDT')['asset']
    v_asset_usdt_free = client.get_asset_balance(asset='USDT')['free']
    v_asset_usdt_locked = client.get_asset_balance(asset='USDT')['locked']
    
    v_asset_eth = client.get_asset_balance(asset='ETH')['asset']
    v_asset_eth_free = client.get_asset_balance(asset='ETH')['free']
    v_asset_eth_locked = client.get_asset_balance(asset='ETH')['locked']
    
    print(balance)
    
    #return str(binance)            

def digi_count(num,digi):
    
    digi_place = math.pow(10,digi)
    
    return math.floor(num * digi_place) / digi_place 


def binance_dual_sell_market_order():
    pass
    
def binance_dual_buy_market_order():    
    pass


def split_number(total, min_value, max_value):
    result = []
    remaining_total = total
    
    if total > 1000 and total <= 5000:
        max_value = max_value + 100
        
    elif total > 5000 and total <= 10000:
        max_value = max_value + 200
        
    elif total > 10000 and total <= 20000:
        max_value = max_value + 400
        
    elif total > 20000 and total <= 40000:
        max_value = max_value + 800
        
    elif total > 40000 and total <= 80000:
        max_value = max_value + 1600

    while remaining_total > max_value:  # 當剩餘總和大於最大值時，繼續分配
        part = random.randint(min_value, max_value)
        result.append(part)
        remaining_total -= part

    if remaining_total >= min_value:  # 當剩餘總和大於等於最小值時，將剩餘部分加入結果列表
        result.append(remaining_total)

    return result



# order_USDT*leverage/lastprice = quantity
def sbs(client,quantity):
    
    print('下單',quantity,'顆,單量太大')
    result = split_number(quantity*lastprice/leverage, 200, 500)
    print('拆成',result,'分開下單')
    print('')
    sp_result = [x * leverage / lastprice for x in result]
    print(sp_result)
    print('')

    
    for x in range (0,len(sp_result)):
        
        print('第',x+1,'筆,',sp_result[x])
        
        try:
            client.futures_create_order(
                symbol = coin_symbol,
                side='SELL',
                type='MARKET',
                quantity=Decimal(str(round(sp_result[x],digi_q))), # you can use Decimals
                recvWindow=receive_windows
            )

        except Exception as e:
            print(f'(sp_sell_market)錯誤訊息: {e}')
            print('價位:',lastprice,'顆數:',round(sp_result[x],digi_q))
            if str(e) == 'APIError(code=-2019): Margin is insufficient.':

                print('餘額不足','現在時間:',now_time())
                #return 0

            elif str(e) == 'APIError(code=-1001): Internal error; unable to process your request. Please try again.':

                print('無法下單請重新再試一次')

        else:
            #print('賣單成功,交易ID: ',order['orderId'],',現在時間:',now_time())
            pass

        time.sleep(0.2)

# order_USDT*leverage/lastprice = quantity        
def binance_sell_market_order(client,quantity):
    
    global record_profit, sell_time
    
    if start_bet == 1 and stop_bet:
    
        if quantity*lastprice/leverage >= 1000 and split_flag == 1:

            sbs(client,quantity)


        else:


            try:
                client.futures_create_order(
                    symbol = coin_symbol,
                    side='SELL',
                    type='MARKET',
                    quantity=Decimal(str(round(quantity,digi_q))), # you can use Decimals
                    recvWindow=receive_windows
                )

            except Exception as e:
                print(f'(sell_market)錯誤訊息: {e}')
                print('價位:',lastprice,'顆數:',round(quantity,digi_q))
                if str(e) == 'APIError(code=-2019): Margin is insufficient.':

                    print('餘額不足','現在時間:',now_time())
                    return 0

                elif str(e) == 'APIError(code=-1001): Internal error; unable to process your request. Please try again.':

                    print('無法下單請重新再試一次')

            else:
                #print('賣單成功,交易ID: ',order['orderId'],',現在時間:',now_time())
                pass
   
    if len(hold_buy_set) > 0:
            
        if round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate) > 0:

            print('前次獲利:',record_profit)
            print('本次獲利:',round((order_USDT/2*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate/2))
            record_profit = record_profit + round((order_USDT/2*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate/2)
            print('累積獲利:',record_profit)
    
        print('                                                         ',end = '')
        print('多單分批獲利出場位置',lastprice,'平倉成功,現在時間:',now_time())
    
    else:
        print('                                                         ',end = '')
        print('空單進場時間:',now_time(),',位置',lastprice,'槓桿倍數:',leverage)  
    
    sell_time = now_time()
    print('                                                         ',end = '')
    print('目前餘額為:',get_av_balance(client, time),'USDT')       
    


def sbb(client,quantity):
    
    print('下單',quantity,'顆,單量太大')
    result = split_number(quantity*lastprice/leverage, 200, 500)
    print('拆成',result,'分開下單')
    print('')
    sp_result = [x * leverage / lastprice for x in result]
    print(sp_result)
    print('')

    
    for x in range (0,len(sp_result)):
        
        print('第',x+1,'筆,',sp_result[x])
        
        try:
            order = client.futures_create_order(
                symbol=coin_symbol, 
                side='BUY', 
                type='MARKET',
                quantity=Decimal(str(round(sp_result[x],digi_q))), # you can use Decimals
                recvWindow=receive_windows
            )

        except Exception as e:
            print(f'(buy_market)錯誤訊息: {e}')
            print('價位:',lastprice,'顆數:',round(sp_result[x],digi_q))
            if str(e) == 'APIError(code=-2019): Margin is insufficient.':
                print('餘額不足')
#                return 0

            elif str(e) == 'APIError(code=-1001): Internal error; unable to process your request. Please try again.':

                print('無法下單請重新再試一次')

        else:
            pass
            #print('買單成功,交易ID: ',order['orderId'],',現在時間:',now_time())

        time.sleep(0.2)
        
        
    
def binance_buy_market_order(client,quantity):
    
    global record_profit, buy_time
    
    if start_bet == 1 and stop_bet:
        
        if quantity*lastprice/leverage >= 1000 and split_flag == 1:

            sbb(client,quantity)


        else:
            
            try:
                order = client.futures_create_order(
                    symbol=coin_symbol, 
                    side='BUY', 
                    type='MARKET',
                    quantity=Decimal(str(round(quantity,digi_q))), # you can use Decimals
                    recvWindow=receive_windows
                )

            except Exception as e:
                print(f'(buy_market)錯誤訊息: {e}')
                print('價位:',lastprice,'顆數:',round(quantity,digi_q))
                if str(e) == 'APIError(code=-2019): Margin is insufficient.':
                    print('餘額不足')
                    return 0

                elif str(e) == 'APIError(code=-1001): Internal error; unable to process your request. Please try again.':

                    print('無法下單請重新再試一次')

            else:
                pass
                #print('買單成功,交易ID: ',order['orderId'],',現在時間:',now_time())
            
    if len(hold_sell_set) > 0:
        
        if round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate) > 0:

            print('前次獲利:',record_profit)
            print('本次獲利:',round((order_USDT/2*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate/2))
            record_profit = record_profit + round((order_USDT/2*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate/2)
            print('累積獲利:',record_profit)
    
        print('                                                         ',end = '')
        print('空單分批獲利出場位置',lastprice,'平倉成功,現在時間:',now_time())
    
    else:
        
        print('                                                         ',end = '')
        print('多單進場時間:',now_time(),',位置',lastprice,'槓桿倍數:',leverage)  
    
    
    buy_time = now_time() 
    print('                                                         ',end = '')
    print('目前餘額為:',get_av_balance(client, time),'USDT')     
    
    
def part_sellout_order(way,quantity,count):
    
    if len(hold_buy_set) > 0:
        
        binance_sell_market_order(client,quantity)
    
    
    if len(hold_sell_set) > 0:
        
        binance_buy_market_order(client,quantity)
    
    

def binance_sell_stop_market():
    
    global order_id
    
    if start_bet == 1:
        try:
            client.futures_create_order(symbol=symbol, 
                                    side="BUY", 
                                    type="STOP_MARKET", 
                                    quantity = 100, 
                                    stopPrice= round(stop_loss_set[len(stop_loss_set)-1],2), 
                                    closePositon = 'true', 
                                    reduceOnly='true')   

            
        except Exception as e:
            print(f'(sell_stop_market)錯誤訊息: {e}')
            if str(e) == 'APIError(code=-2019): Margin is insufficient.':
                print('餘額不足')
                return 0
            
            elif str(e) == 'APIError(code=-1001): Internal error; unable to process your request. Please try again.':
                
                print('無法下單請重新再試一次')
        
        '''
        order_id = client.futures_get_open_orders(symbol=symbol)[0]['orderId']
        print('                                                            ',end = '')
        print('空單開倉,停損點設在:',stop_loss_set[len(stop_loss_set)-1])
        print('                                                            ',end = '')
        print(' stop loss Order Id: ',order_id)
        '''

def binance_buy_stop_market():
    
    global order_id
    
    if start_bet == 1:
        try:
            client.futures_create_order(symbol=symbol, 
                                    side="SELL", 
                                    type="STOP_MARKET", 
                                    quantity = 100, 
                                    stopPrice= round(stop_loss_set[len(stop_loss_set)-1],2), 
                                    closePositon = 'true', 
                                    reduceOnly='true') 

            
        except Exception as e:
            print(f'(buy_stop_market)錯誤訊息: {e}')
            
            if str(e) == 'APIError(code=-2019): Margin is insufficient.':
                print('餘額不足')
                return 0
            
            elif str(e) == 'APIError(code=-1001): Internal error; unable to process your request. Please try again.':
                
                print('無法下單請重新再試一次')
        
        '''
        order_id = client.futures_get_open_orders(symbol=symbol)[0]['orderId']
        print('                                                            ',end = '')
        print('多單單開倉,停損點設在:',stop_loss_set[len(stop_loss_set)-1])
        print('                                                            ',end = '')
        print(' stop loss Order Id: ',order_id)
        '''
        
            
def binance_close_position(side):
    
    global save_ATR, save_stoch_K, save_stoch_D, stoch_K, stoch_D, record_USDT, order_USDT, hundred_percent_out
    global sellout_level, protect_wash_flag, separate_total_benefit, separate_benefit, BB_sellout_flag, order_USDT_balance
    global buy_already,sell_already, moving_sellout_flag, balance_point
    

    if start_bet == 1 and side != 'NULL':
        try:
            #全部平倉
            order = client.futures_create_order(
                symbol='ETHUSDT', 
                side= side, 
                type='MARKET', 
                quantity=1000, 
                reduceOnly='true') 

        except Exception as e:
            print('(',side,end ='')
            print(f'_close_position)錯誤訊息: {e}')
            if str(e) == 'APIError(code=-2019): Account has insufficient balance for requested action.':

                print('餘額不足','現在時間:',now_time())
                return 0

            
#    RB_profit_record(side)   
    print('---------(close_position)--------------------------         在',lastprice,'平倉成功,現在時間:',now_time())
    time.sleep(1)

    clean_all_vareable()


    

def clean_all_vareable(): # and check conpound
    
    global buy_already, sell_already, hold_buy_set, hold_sell_set, stop_loss_set
    global buy_benefit, sell_benefit, CEUT_buy_count, CEUT_sell_count 
    global rebuy_set, resell_set , restoploss_set
    global sellout_25_flag, sellout_50_flag, sellout_25_50_flag
    global UT_15_boundary_flag
    global sellout_area, limit_flag
    global Up_EMA_5k_flag, Down_EMA_5k_flag
    global Up_EMA_15k_flag, Down_EMA_15k_flag
    global touch_UTST_area_flag, touch_onetime, half_sellout_5k_flag 
    global Buy_st, Sell_st, Dont_buy, Dont_sell, middle_in
    global Buy_15k_st, Sell_15k_st
    global HF_EMA120_5k_flag, HF_EMA120_15k_flag
    global buy_5k_already, sell_5k_already
    global RB_Total_TaxRate, RB_red_continue ,RB_black_continue ,RB_bound ,RB_120ma_bound
    global high_price, low_price
    global RB_hrh_count, RB_lrl_count, RB_bound_count
    global RB_over_x_percent_flag, RB_buy_count, RB_sell_count
    global RB_max_loss_percent, P1P_stopProfit_at_120ma
    global buy_open_price, sell_open_price
    global Grid_over_profit_flag
    global Grid_moving_sellout_flag, Grid_moving_sellout_time, Grid_4percent_flag
    global Grid_return_position, Grid_final_return_position, Grid_1percent_return_flag
    global Grid_sellout_percent, Grid_total_sellout_high, Grid_total_sellout_low

    global targetSingal_buy_high, targetSingal_sell_low, twoSingal_buy_count, twoSingal_sell_count
    global save_sell_K_high_between_two_signal, save_buy_K_low_between_two_signal, test_dependancy,twoSingal_last_signal
    global twoSignal_05percent_flag, twoSignal_3percent_flag, twoSignal_4percent_flag, twoSignal_2percent_flag
    global twoSignal_opposite_signal_flag, twoSignal_last_buy_high_signal, twoSignal_last_sell_low_signal
    
    print('                                                            目前餘額為:',get_av_balance(client, time),'USDT')
    
    
    if sellout_50_flag == 1:

        print('記錄最後進場及停損點,等待重新進場')
        if len(hold_buy_set) != 0:
            rebuy_set.append(hold_buy_set[len(hold_buy_set)-1])
            print('rebuy_set:',rebuy_set)
        if len(hold_sell_set) != 0:
            resell_set.append(hold_sell_set[len(hold_sell_set)-1])
            print('resell_set:',resell_set)
         
        if len(stop_loss_set) != 0:
            restoploss_set.append(stop_loss_set[len(stop_loss_set)-1])
            print('restoploss_set:',restoploss_set)
        
        
        
        

        
    else:
        rebuy_set = []
        resell_set = []
        restoploss_set = []
        

    sellout_25_flag = 0
    buy_already = 0
    sell_already = 0
    hold_buy_set = []
    hold_sell_set = []
    stop_loss_set = []
    UT_15_boundary_flag = 0
    sellout_area = round((lastprice * sellout_percent),2) * (sellout_25_flag + 1)

    buy_benefit = 0
    sell_benefit = 0
    limit_flag = 0
    
    Up_EMA_5k_flag, Down_EMA_5k_flag = 0, 0
    Up_EMA_15k_flag, Down_EMA_15k_flag = 0, 0
    Buy_st, Sell_st = 0, 0
    Buy_15k_st, Sell_15k_st = 0, 0
    
    touch_UTST_area_flag = 0
    touch_onetime = 0
    half_sellout_5k_flag = 0
    Dont_buy, Dont_sell = 0, 0
    middle_in = 1
    HF_EMA120_5k_flag = 0
    HF_EMA120_15k_flag = 0
    buy_5k_already = 0
    sell_5k_already = 0
    RB_Total_TaxRate = 0
    RB_bound = 1
    high_price = 0
    low_price = 0
    RB_hrh_count, RB_lrl_count, RB_bound_count = 0,0,0
    RB_buy_count, RB_sell_count = 0,0
    RB_over_x_percent_flag = 0
    RB_120ma_bound = 1
    RB_max_loss_percent = 0
    P1P_stopProfit_at_120ma = 0
    clean_all_divergence_variable()
    buy_open_price = sell_open_price = 0
    Grid_over_profit_flag = 0
    Grid_moving_sellout_flag = 0
    Grid_4percent_flag = 0
    Grid_1percent_return_flag = 0
    Grid_return_position = []
    Grid_final_return_position = 0
    Grid_sellout_percent = 7
    Grid_total_sellout_high = 0
    Grid_total_sellout_low = 0
    if twoSingal_last_signal == -1:
        CEUT_buy_count = 0
    if twoSingal_last_signal == 1:
        CEUT_sell_count = 0

    twoSignal_05percent_flag = 0
    twoSignal_3percent_flag = 0
    twoSignal_4percent_flag = 0
    twoSignal_2percent_flag = 0
    twoSignal_opposite_signal_flag = 0
    twoSignal_last_buy_high_signal = 0
    twoSignal_last_sell_low_signal = 0

    '''
    if twoSingal_last_signal == 1:    
        if CEUT_buy_count == 1:
            targetSingal_sell_low = []
            save_buy_K_low_between_two_signal = []
        elif CEUT_buy_count >= 2:
            targetSingal_buy_high = []
            save_sell_K_high_between_two_signal = []
        
    elif twoSingal_last_signal == -1:
        if CEUT_sell_count == 1:
            targetSingal_buy_high = []
            save_sell_K_high_between_two_signal = []
        elif CEUT_sell_count >= 2:
    '''        
    
                
#    twoSingal_last_signal = 0
#    test_dependancy = []
    
    if conpound_flag == 1:
        double_conpound_interest(divid_total_money)
    
    
def twoSignal_check_lead_trade_profit():

    pass
#    local_buffer_USDT = round((local_get_av_balance - record_USDT) * 0.05 ,2)

    
    
# 改複利 n = 5 

def double_conpound_interest(n): 
    
    global record_USDT, order_USDT, orig_USDT, sellout_divid, buffer_USDT, divid_total_money,leverage
    global Grid_moving_sellout_time
    
    local_get_av_balance = get_av_balance(client, time) + contract_balance_buffer - buffer_USDT
    local_buffer_USDT = 0
    
    print('local_get_av_balance:',local_get_av_balance)
    print('record_USDT:',record_USDT)
    
    
    if local_get_av_balance > 0:

        '''
        if local_get_av_balance > 10000 and local_get_av_balance <= 50000:
            divid_total_money = n = 12
            print('                                                            投資本金超過10000u,分配資金比例改為',divid_total_money)
            
        elif local_get_av_balance > 50000 and local_get_av_balance <= 100000:
            divid_total_money = n = 13
            print('                                                            投資本金超過50000u,分配資金比例改為',divid_total_money)
        
        elif local_get_av_balance > 100000 and local_get_av_balance <= 500000:
            divid_total_money = n = 14
            print('                                                            投資本金超過100000u,分配資金比例改為',divid_total_money)
        
        elif local_get_av_balance > 500000 and local_get_av_balance <= 1000000:
            divid_total_money = n = 15
            print('                                                            投資本金超過500000u,分配資金比例改為',divid_total_money)
        
        elif local_get_av_balance > 1000000 and local_get_av_balance <= 1500000:
            divid_total_money = n = 16
            print('                                                            投資本金超過1000000u,分配資金比例改為',divid_total_money)
        
        elif local_get_av_balance > 1500000 and local_get_av_balance <= 2000000:
            divid_total_money = n = 18
            print('                                                            投資本金超過1500000u,分配資金比例改為',divid_total_money)
        
        elif local_get_av_balance > 2000000 :
            leverage = 20
            divid_total_money = n = 10
            print('                                                            投資本金超過2000000u,分配資金比例改為',divid_total_money)
        '''
    
        if Grid_moving_sellout_time > 0 and all_buffer == 1:
            
            print('                                                            網格獲利:',Grid_moving_sellout_time ,'次')

            local_buffer_USDT = round((local_get_av_balance - record_USDT) * 0.03 ,2)
            buffer_USDT = buffer_USDT + local_buffer_USDT
            print('                                                            保留:',local_buffer_USDT ,'u ,累積保留:',buffer_USDT ,'u')

            Grid_moving_sellout_time = 0
    
        if local_get_av_balance > record_USDT:

            print('---------(Increase Order_USDT base)------------------')
            print('                                                            獲利:',round(local_get_av_balance - record_USDT,2) ,'u')

            local_buffer_USDT = round((local_get_av_balance - record_USDT) * 0.05 ,2)
            buffer_USDT = buffer_USDT + local_buffer_USDT
            print('                                                            保留:',local_buffer_USDT ,'u ,累積保留:',buffer_USDT ,'u')


            record_USDT = local_get_av_balance
            order_USDT = round(record_USDT/n,2)


            print('                                                            最高本金增加為:',record_USDT,',order_USDT改為:',order_USDT,'u')

            if order_USDT * n < local_get_av_balance:
                print('                                                            目前累積保留u為:',round(local_get_av_balance - (order_USDT * n),2),'u')


        if local_get_av_balance < record_USDT * 0.3:  # 目前資金低於最高資金3成,即重新分配進場資金

            print('---------(Decrease Order_USDT base)------------------')
            print('                                                            目前資金(',round(local_get_av_balance,2),')低於最高資金(',record_USDT,')3成')


            record_USDT = local_get_av_balance
            order_USDT = round(record_USDT/n,2)
            print('                                                            即重新分配進場資金,record_USDT改為:',record_USDT,'u')

            print('                                                                            order_USDT改為:',order_USDT,'u')
            print('                                                                            buff_USDT為:',buffer_USDT,'u')

    else:
        
        record_USDT = buffer_USDT/2
        buffer_USDT = buffer_USDT/2
        order_USDT = round(record_USDT/n,2)
        print('                                                            投資本金歸零,保留資金重新分配,record_USDT改為:',record_USDT,'u')

        print('                                                                                     order_USDT改為:',order_USDT,'u')
        print('                                                                                     buff_USDT為:',buffer_USDT,'u')

        print('                                                            重新分配完成')
        

def get_av_balance(client, time):
    
    global av_balance, mg_balance ,ur_balance, wt_balance, initialMargin, wt_balance

    while True:
        try:
            account_info = client.futures_account()

            for asset in account_info["assets"]:
                if asset["asset"] == "USDT":
                    av_balance = float(asset["availableBalance"])
                    mg_balance = float(asset["marginBalance"])
                    ur_balance = float(asset["unrealizedProfit"])
                    initialMargin = float(asset["initialMargin"])
                    wt_balance = float(asset["walletBalance"])

            if len(account_info) > 0:
                wt_balance = float("{:.2f}".format(wt_balance))
                
                return wt_balance 

        except Exception as e:
            print("(get_av_balance)Account Error:", e)
            time.sleep(1)
            pass  

        
def get_ur_balance(client, time):
    
    global ur_balance

    while True:
        try:
            account_info = client.futures_account()

            for asset in account_info["assets"]:
                if asset["asset"] == "USDT":
                    ur_balance = float(asset["unrealizedProfit"])

            if len(account_info) > 0:
                ur_balance = float("{:.2f}".format(ur_balance))
                return ur_balance

        except Exception as e:
            print("(get_ur_balance)Account Error:", e)
            time.sleep(1)
            pass        

def get_ur_balance_flag(client, time):
    
    global ur_balance

    while True:
        try:
            account_info = client.futures_account()

            for asset in account_info["assets"]:
                if asset["asset"] == "USDT":
                    ur_balance = float(asset["unrealizedProfit"])

            if len(account_info) > 0:
                ur_balance = float("{:.2f}".format(ur_balance))
                return 1

        except Exception as e:
            print("(get_ur_balance_flag)Account Error:", e)
            time.sleep(1)
            pass 



def hold_set_average():
    
    global average_hold_buy, average_hold_sell
    
    average_hold_buy = 0 
    average_hold_sell = 0
    
    for x in range (0,len(hold_buy_set)):
        average_hold_buy = average_hold_buy + hold_buy_set[x]
    for x in range (0,len(hold_sell_set)):
        average_hold_sell = average_hold_sell + hold_sell_set[x]
    
    if len(hold_buy_set) != 0: 
        average_hold_buy = round(average_hold_buy/len(hold_buy_set),2)
    if len(hold_sell_set) != 0: 
        average_hold_sell = round(average_hold_sell/len(hold_sell_set),2)
        

#    average_hold_buy = round(np.average(hold_buy_set),2)
#    average_sell_buy = round(np.average(hold_sell_set),2)


def stoploss_and_sellout_thread():
    
    global t_lastprice
    
    if len(Thread_queue)>0:
        t_lastprice = Thread_queue.popleft()
        HF_stopProfit(0,t_lastprice)
#        P1P_AfretProtect_rebuysell(0, t_lastprice)
        
        if len(stop_loss_set) == 0 and init == 1:
            P1P_After_stoploss_restart_goReturn(0,t_lastprice)
#            Grid_start_stopProfit(profit_start,t_lastprice)
            Grid_stopProfit_in_1percent(0,t_lastprice)
        
        if len(stop_loss_set) > 0 and init == 1:
            stoploss_sellout(1, t_lastprice)
            twoSignal_pullback_2_percent(1, t_lastprice)
            stopProfit_sellout(0, t_lastprice)
            limit_120ma_sellout(0,t_lastprice)
            twoSignal_moving_close_sellout(0,t_lastprice)
            max_loss_percent(0,t_lastprice)
            P1P_Protect_stopProfit(0,t_lastprice)
            cross_120ma_order(0,t_lastprice)
#            Grid_raise_order_stopProfit_over_1percent(0, t_lastprice)
#            Grid_moving_sellout_and_rebuy(0, t_lastprice)
#            Grid_4percent_overUT(1, t_lastprice)
            twoSignal_stop_profit(0,t_lastprice)
            
        if wait2touch_120ma != 0 and init == 1 :
            time.sleep(1)
            cross_120ma_check(0,t_lastprice)
            CEUT_cross_120ma_check(0,t_lastprice)
            
        if init == 1 and directly_close == 1:
            stop_long_short()
                        
        
def re_buysell(bet,price):
    
    global buy_already, sell_already, hold_buy_set, hold_sell_set, stop_loss_set
    global order_count, order_flag, stoploss_continue_order
    global rebuy_set, resell_set, restoploss_set
    global sellout_25_flag, sellout_50_flag
    
    if bet == 1:
        if sellout_50_flag == 1:
            
            if len(rebuy_set) == 1: 
                if t_lastprice <= rebuy_set[0]:

                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(t_lastprice)
                    stop_loss_set.append(restoploss_set[0])
                    buy_already = 1
                    order_flag = 1
                    order_count = 1
                    rebuy_set = []
                    restoploss_set = []
                    sellout_25_flag = 0
                    sellout_50_flag = 0

                    print('                                                            ', end = '')
                    print('反手前,在',t_lastprice,'重新進場多,停損設在',stop_loss_set[len(stop_loss_set)-1])
            

            if len(resell_set) == 1:   

                if t_lastprice >= resell_set[0]:
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(t_lastprice)
                    stop_loss_set.append(restoploss_set[0])
                    sell_already = 1
                    order_flag = 1
                    order_count = 1
                    resell_set = []
                    restoploss_set = []
                    sellout_25_flag = 0
                    sellout_50_flag = 0
                    print('                                                            ', end = '')
                    print('反手前,在',t_lastprice,'重新進場空,停損設在',stop_loss_set[len(stop_loss_set)-1])

    
def hold_buysell_2_average_buysell():
    
    if len(hold_buy_set) > 0:
        
        if len(hold_buy_set) == 1:
            return hold_buy_set[len(hold_buy_set) - 1]
        
        elif len(hold_buy_set) >1 :
            return average_hold_buy
        
    elif len(hold_sell_set) > 0:
        
        if len(hold_sell_set) == 1:
            return hold_sell_set[len(hold_sell_set) - 1]
        
        elif len(hold_sell_set) >1 :
            return average_hold_sell


def stopProfit_sellout(bet, price):
    
    global buy_already, sell_already, hold_buy_set, hold_sell_set, stop_loss_set
    global order_count, order_flag, stoploss_continue_order
    global stoploss_time, limit_flag, record_loss, re_buysell_flag
    global P1P_stoploss_flag, macd_up2zero_flag, macd_down2zero_flag
    global ceut_continue, wait2touch_120ma, ceut_shoot_flag
    
    
    if bet == 1:
        
        if len(hold_buy_set) > 0:
        
            if price > hold_buy_set[len(hold_buy_set)-1] + price * 0.01 :

                #record_loss = record_loss - abs(price - hold_buy_set[len(hold_buy_set)-1])
                #平倉
                binance_close_position('SELL')
                hold_buy_set = []
                stop_loss_set = []
                clean_all_vareable()
                ceut_continue = -1
                wait2touch_120ma = ceut_shoot_flag = 0
                
#                KH()
#                print('                                                            連續停損次數:',stoploss_time,' ,Killtime:',kill_head)
                print('                                                            停利多單,在',price,',現在時間:',now_time())
                


                #停損出場

        elif len(hold_sell_set) > 0:

            if price < hold_sell_set[len(hold_sell_set)-1] - price * 0.01 :

                #record_loss = record_loss - abs(price - hold_sell_set[len(hold_sell_set)-1])
                #先平倉
                binance_close_position('BUY')
                hold_sell_set = []
                stop_loss_set = []
                clean_all_vareable()
                ceut_continue = 1
                wait2touch_120ma = ceut_shoot_flag = 0
                
#                KH()
#                print('                                                            連續停損次數:',stoploss_time,' ,Killtime:',kill_head)
                print('                                                            停利空單,在',price,',現在時間:',now_time())


                #停損出場        
        
def stoploss_sellout(bet, price):
    
    global buy_already, sell_already, hold_buy_set, hold_sell_set, stop_loss_set
    global order_count, order_flag, stoploss_continue_order
    global stoploss_time, limit_flag, record_loss, re_buysell_flag
    global P1P_stoploss_flag, macd_up2zero_flag, macd_down2zero_flag
#CEUT
    global Grid_raise_order, Grid_sellout_percent, Grid_stoploss_time
    global CEUT_buy_count, CEUT_sell_count, twoSignal_05percent_flag, twoSingal_last_signal
    
    if bet == 1:
        
        if len(hold_buy_set) > 0:
        
            if price < stop_loss_set[len(stop_loss_set)-1]:

                #record_loss = record_loss - abs(price - hold_buy_set[len(hold_buy_set)-1])
                #平倉
                wait2touch_120ma = 1
                binance_close_position('SELL')
                hold_buy_set = []
                stop_loss_set = []
                buy_already = 0
                stoploss_time = stoploss_time + 1
                limit_flag = 0
                clean_all_vareable()
                re_buysell_flag = 1
                P1P_stoploss_flag = -1
                '''
                if twoSignal_05percent_flag == 0:
                    CEUT_buy_count = 0
                else:
                '''
                if twoSignal_05percent_flag == 1:
                    CEUT_sell_count = 1
                    twoSingal_last_signal = -1
                    print('反手多單停損,twoSingal_last_signal改回:',twoSingal_last_signal,'空單訊號改回:',CEUT_sell_count)
                else:
                    CEUT_buy_count = 1
                
#                clean_all_vareable()
                
                
#                KH()
                print('                                                            連續停損次數:',stoploss_time,' ,Killtime:',kill_head)
                print('                                                            停損多單,在',price,',現在時間:',now_time())
                
                if Grid_CEUT == 1:
                    if Grid_raise_order_flag == 1:
                        
                        Grid_raise_order += 1

                        if Grid_raise_order == 3 and Grid_KH_flag:
                            Grid_raise_order = 0 
                            print('                                                            連續虧損超過2次,不加碼重新開始')
                            average_order_USDT()

                        else:
                            print('                                                            下次進場加碼',(math.pow(2,Grid_raise_order+1) - Grid_raise_order_percent),'單位')



                #停損出場

        elif len(hold_sell_set) > 0:

            if price > stop_loss_set[len(stop_loss_set)-1]:

                #record_loss = record_loss - abs(price - hold_sell_set[len(hold_sell_set)-1])
                #先平倉
                wait2touch_120ma = -1
                binance_close_position('BUY')
                hold_sell_set = []
                stop_loss_set = []
                sell_already = 0
                stoploss_time = stoploss_time + 1
                limit_flag = 0
                clean_all_vareable()
                re_buysell_flag = 1
                P1P_stoploss_flag = 1
                '''
                if twoSignal_05percent_flag == 0:
                    CEUT_sell_count = 0
                else:
                '''
                if twoSignal_05percent_flag == 1:
                    CEUT_buy_count = 1
                    twoSingal_last_signal = 1
                    print('反手空單停損,twoSingal_last_signal改回:',twoSingal_last_signal,'多單訊號改回:',CEUT_buy_count)
                else:
                    CEUT_sell_count = 1
                
#                clean_all_vareable()
                
                
                
#                KH()
#                print('                                                            連續停損次數:',stoploss_time,' ,Killtime:',kill_head)
                print('                                                            停損空單,在',price,',現在時間:',now_time())

                if Grid_CEUT == 1:
                    if Grid_raise_order_flag == 1:
                    
                        Grid_raise_order += 1

                        if Grid_raise_order == 3 and Grid_KH_flag:
                            Grid_raise_order = 0 
                            print('                                                            連續虧損超過2次,不加碼重新開始')
                            average_order_USDT() 

                        else:
                            print('                                                            下次進場加碼',(math.pow(2,Grid_raise_order+1) - Grid_raise_order_percent),'單位')



                #停損出場


def stoploss_buy_sellout(price):
    
    global buy_already, sell_already, hold_buy_set, hold_sell_set, stop_loss_set
    global order_count, order_flag, stoploss_continue_order
    global stoploss_time, limit_flag, record_loss, re_buysell_flag
    
    if buy_already == 1 or buy_5k_already == 1:
        
            

        #record_loss = record_loss - abs(price - hold_buy_set[len(hold_buy_set)-1])
        #平倉
        hold_buy_set = []
        stop_loss_set = []
        buy_already = 0
        binance_close_position('SELL')
        stoploss_time = stoploss_time + 1
        limit_flag = 0
        clean_all_vareable()
        re_buysell_flag = 1
#        KH()
#        print('                                                            連續停損次數:',stoploss_time,' ,Killtime:',kill_head
        print('                                                            多單出場,在',price,',現在時間:',now_time())
                

    
def stoploss_sell_sellout(price):
            
    global buy_already, sell_already, hold_buy_set, hold_sell_set, stop_loss_set
    global order_count, order_flag, stoploss_continue_order
    global stoploss_time, limit_flag, record_loss, re_buysell_flag    
        
    if sell_already == 1 or sell_5k_already == 1:

        #record_loss = record_loss - abs(price - hold_sell_set[len(hold_sell_set)-1])
        #先平倉
        hold_sell_set = []
        stop_loss_set = []
        sell_already = 0
        binance_close_position('BUY')
        stoploss_time = stoploss_time + 1
        limit_flag = 0
        clean_all_vareable()
        re_buysell_flag = 1
#        KH()
#        print('                                                            連續停損次數:',stoploss_time,' ,Killtime:',kill_head)
        print('                                                            空單出場,在',price,',現在時間:',now_time())


                #停損出場    
                

    
def limit_sellout(price,use_strategy):
    
    global limit_flag, sellout_25_flag, high_price, low_price, sellout_price
    
    if use_strategy == '2550':
    
        if buy_already == 1 or buy_5k_already == 1:
            if limit_flag == 0 and sellout_25_flag == 0 and price >= hold_buy_set[len(hold_buy_set) - 1] + sellout_bound - 2:
                high_price = price
                limit_flag = 25
                print('目前多單進入第1段極限區間,低於最高點到出場點間距,將保護出場')

            elif limit_flag == 25 and sellout_25_flag == 1 and price >= hold_buy_set[len(hold_buy_set) - 1] + (2 * sellout_bound) - 2 :
                high_price = price
                limit_flag = 50
                print('目前多單進入第2段極限區間,低於最高點到出場點間距,將保護出場')

        elif sell_already == 1 or sell_5k_already == 1:
            if limit_flag == 0 and sellout_25_flag == 0 and price <= hold_sell_set[len(hold_sell_set) - 1] - sellout_bound + 2:
                low_price = price
                limit_flag = -25
                print('目前空單進入第1段極限區間,高於最低點到出場點間距,將保護出場')

            elif limit_flag == -25 and sellout_25_flag == 1 and price <= hold_sell_set[len(hold_sell_set)-1] - (2 * sellout_bound) + 2 :
                low_price = price
                limit_flag = -50
                print('目前空單進入第2段極限區間,高於最低點到出場點間距,將保護出場')
        
        
        

        if limit_flag == 25 and sellout_25_flag == 0:
            if price > high_price:
                high_price = price
                sellout_price = hold_buy_set[len(hold_buy_set) - 1] + sellout_bound - high_price
                print('第1段目前最高點改成:',high_price,'拉回出場點改為:',round(high_price - sellout_price,2))

            

            if price < high_price - sellout_price :
                print('多單目前位置:',price,'從第1段最高點:',high_price,'拉回:',round(sellout_price,2),'多單直接出場50%')
                binance_sell_market_order(client,order_USDT*leverage/price/2*len(hold_buy_set))
                sellout_25_flag = 1

        elif limit_flag == 50 and sellout_25_flag == 1:
            if price > high_price:
                high_price = price
                sellout_price = hold_buy_set[len(hold_buy_set) - 1] + (2 * sellout_bound) - high_price
                print('第2段目前最高點改成:',high_price,'拉回出場點改為:',round(high_price - sellout_price,2))

            

            if price < high_price - sellout_price :
                print('多單目前位置:',price,'從第2段最高點:',high_price,'拉回:',round(sellout_price,2),'多單直接全部出場')
                binance_close_position('SELL')
                sellout_25_flag = 0



        elif limit_flag == -25 and sellout_25_flag == 0:
            if price < low_price:
                low_price = price 
                sellout_price = low_price - (hold_sell_set[len(hold_sell_set) - 1] - sellout_bound)
                print('第1段目前最低點改成:',low_price,'拉回出場點改為:',round(low_price + sellout_price,2))

            
            if price > low_price + sellout_price :
                print('空單目前位置:',price,'從第1段最低點:',low_price,'拉回:',round(sellout_price,2),'空單直接出場50%')
                binance_buy_market_order(client,order_USDT*leverage/price/2*len(hold_buy_set))
                sellout_25_flag = 1

        elif limit_flag == -50 and sellout_25_flag == 1:
            if price < low_price:
                low_price = price 
                sellout_price = low_price - (hold_sell_set[len(hold_sell_set)-1] - (2 * sellout_bound))
                print('第2段目前最低點改成:',low_price,'拉回出場點改為:',round(low_price + sellout_price,2))

            
            if price > low_price + sellout_price :
                print('空單目前位置:',price,'從第2段最低點:',low_price,'拉回:',round(sellout_price,2),'空單直接全部出場')
                binance_close_position('BUY')
                sellout_25_flag = 0
                
                
                
                
    elif use_strategy == '10%':
        
        if sellout_25_flag <= sellout_time:
            sellout_area = round((price * sellout_percent),2) * (sellout_25_flag + 1)
        
        if buy_already == 1 or buy_5k_already == 1:
            
            if len(hold_buy_set) == 1:
                
                if limit_flag == 0 and sellout_25_flag < sellout_time  and price >= hold_buy_set[len(hold_buy_set) - 1] + sellout_area - 2:
                    high_price = price
                    limit_flag = 1
                    print('目前多單進入第',sellout_25_flag + 1,'段極限區間,低於最高點到出場點間距,將保護出場')
                    print('原出場點:',hold_buy_set[len(hold_buy_set) - 1] + sellout_area)
                    
            elif len(hold_buy_set) > 1:
                
                if limit_flag == 0 and sellout_25_flag < sellout_time  and price >= average_hold_buy + sellout_area - 2:
                    high_price = price
                    limit_flag = 1
                    print('目前多單進入第',sellout_25_flag + 1,'段極限區間,低於最高點到出場點間距,將保護出場')
                    print('平均出場點:',average_hold_buy + sellout_area)
            

        elif sell_already == 1 or sell_5k_already == 1:
            
            if len(hold_sell_set) == 1:
                
                if limit_flag == 0 and sellout_25_flag < sellout_time and price <= hold_sell_set[len(hold_sell_set) - 1] - sellout_area + 2:
                    low_price = price
                    limit_flag = -1
                    print('目前空單進入第',sellout_25_flag + 1,'段極限區間,高於最低點到出場點間距,將保護出場')
                    print('原出場點:',hold_sell_set[len(hold_sell_set) - 1] - sellout_area)

            elif len(hold_sell_set) > 1:
                
                if limit_flag == 0 and sellout_25_flag < sellout_time and price <= average_hold_sell - sellout_area + 2:
                    low_price = price
                    limit_flag = -1
                    print('目前空單進入第',sellout_25_flag + 1,'段極限區間,高於最低點到出場點間距,將保護出場')
                    print('平均出場點:',average_hold_sell - sellout_area)
        
        
        
        
        
        if limit_flag == 1 and sellout_25_flag < sellout_time:
            if price > high_price:
                high_price = price
                
                if len(hold_buy_set) == 1: 
                    sellout_price = hold_buy_set[len(hold_buy_set) - 1] + sellout_area - high_price
                    print('第',sellout_25_flag + 1,'段目前最高點改成:',high_price,'拉回出場點改為:',round(high_price - sellout_price,2))

                elif len(hold_buy_set) > 1:
                    sellout_price = average_hold_buy + sellout_area - high_price
                    print('第',sellout_25_flag + 1,'段目前最高點改成:',high_price,'拉回平均出場點改為:',round(high_price - sellout_price,2))

            

            if price < high_price - sellout_price :
                print('多單目前位置:',price,'從第',sellout_25_flag + 1,'段最高點:',high_price,'拉回:',round(sellout_price,2),'多單直接出場',round((100/sellout_divid),2),'%')
                
                if len(hold_buy_set) == 1: 
                    binance_sell_market_order(client,order_USDT*leverage/price/sellout_divid*len(hold_buy_set))
                if len(hold_buy_set) > 1: 
                    binance_sell_market_order(client,sellout_unit*leverage/price/sellout_divid)
                
                sellout_25_flag = sellout_25_flag + 1
                limit_flag = 0
                
                
        elif limit_flag == -1 and sellout_25_flag < sellout_time:
            if price < low_price:
                low_price = price 
                
                if len(hold_sell_set) == 1:
                    sellout_price = low_price - (hold_sell_set[len(hold_sell_set) - 1] - sellout_area)
                    print('第',sellout_25_flag + 1,'段目前最低點改成:',low_price,'拉回出場點改為:',round(low_price + sellout_price,2))

                elif len(hold_sell_set) > 1:
                    sellout_price = low_price - (average_hold_sell - sellout_area)
                    print('第',sellout_25_flag + 1,'段目前最低點改成:',low_price,'拉回平均出場點改為:',round(low_price + sellout_price,2))

            
            if price > low_price + sellout_price :
                print('空單目前位置:',price,'從第',sellout_25_flag + 1,'段最低點:',low_price,'拉回:',round(sellout_price,2),'空單直接出場',round((100/sellout_divid),2),'%')
                
                if len(hold_sell_set) == 1:
                    binance_buy_market_order(client,order_USDT*leverage/price/sellout_divid*len(hold_sell_set))
                if len(hold_sell_set) > 1:
                    binance_buy_market_order(client,sellout_unit*leverage/price/sellout_divid)
                
                sellout_25_flag = sellout_25_flag + 1
                limit_flag = 0

def sellout_25_50(bet, price):    
    
    global sellout_25_50_flag, sellout_25_flag, sellout_50_flag, stop_loss_set
    global sellout_bound
    
    

    
    if bet == 1:
            
        limit_sellout(price,'2550')    
            
        if buy_already == 1 or buy_5k_already == 1:
            
            if sellout_bound_const_flag == 0:
                sellout_bound = round((lastprice * sellout_percent),2)

            if price >= hold_buy_set[len(hold_buy_set) - 1] + sellout_bound and price < hold_buy_set[len(hold_buy_set) - 1] + (2 * sellout_bound) and sellout_25_flag == 0:

                binance_sell_market_order(client,order_USDT*leverage/price/2*len(hold_buy_set))

                sellout_25_flag = 1
                
                if strategy_25_50_continue_flag == 0:
                    if stop_loss_set[len(stop_loss_set) - 1] < hold_buy_set[len(hold_buy_set) - 1] - sellout_bound:
                        stop_loss_set = [hold_buy_set[len(hold_buy_set) - 1] - sellout_bound]
                        print('                                                            ', end = '')
                        print('多單獲利25塊,減碼賣出1/2,停損反轉點平移到:',hold_buy_set[len(hold_buy_set) - 1] - sellout_bound,now_time())        

                print('                                                            ', end = '')
                print('多單獲利25塊,減碼賣出1/2',now_time())    
    
            elif price >= hold_buy_set[len(hold_buy_set) - 1] + (2 * sellout_bound) and sellout_50_flag == 0:
                
                if strategy_25_50_continue_flag == 1:
                    sellout_50_flag = 1
                binance_close_position('SELL')

                print('                                                            ', end = '')
                print('多單獲利50塊,剩下全部出場')
                if strategy_25_50_continue_flag == 1:
                    print('                                                            ', end = '')
                    print('等待重新回到進場點:',rebuy_set[len(rebuy_set) - 1],',',now_time())
                
                print('')    
                
        elif sell_already == 1 or sell_5k_already == 1:
            
            if sellout_bound_const_flag == 0:
                sellout_bound = round((lastprice * sellout_percent),2)

            if price <= hold_sell_set[len(hold_sell_set) - 1] - sellout_bound and price > hold_sell_set[len(hold_sell_set) - 1] - (2 * sellout_bound) and sellout_25_flag == 0:

                binance_buy_market_order(client,order_USDT*leverage/price/2*len(hold_sell_set))

                sellout_25_flag = 1
                
                if strategy_25_50_continue_flag == 0:
                    if stop_loss_set[len(stop_loss_set) - 1] > hold_sell_set[len(hold_sell_set) - 1] + sellout_bound:
                        stop_loss_set = [hold_sell_set[len(hold_sell_set) - 1] + sellout_bound]
                        print('                                                            ', end = '')
                        print('空單獲利25塊,減碼賣出1/2,停損反轉點平移到:',hold_sell_set[len(hold_sell_set) - 1] + sellout_bound,now_time())

                print('                                                            ', end = '')
                print('空單獲利25塊,減碼賣出1/2',now_time())
                      
            elif price <= hold_sell_set[len(hold_sell_set)-1] - (2 * sellout_bound) and sellout_50_flag == 0:

                if strategy_25_50_continue_flag == 1:
                    sellout_50_flag = 1
                binance_close_position('BUY')

                print('                                                            ', end = '')
                print('空單獲利50塊,剩下全部出場')
                if strategy_25_50_continue_flag == 1:
                    print('                                                            ', end = '')
                    print('等待重新回到進場點:',resell_set[len(resell_set)-1],',',now_time())

                print('')    
                
def sellout_10percent(bet, price):    
    
    global sellout_25_50_flag, sellout_25_flag, sellout_50_flag, stop_loss_set
    global sellout_bound, sellout_area, limit_flag 

    
    if bet == 1:
        
        limit_sellout(price,'10%')
        
        '''
        if sellout_25_flag <= sellout_time and sellout_bound_const_flag == 0:
            sellout_area = round((price * sellout_percent),2) * (sellout_25_flag + 1)
            
        if buy_already == 1 and sellout_25_flag <= sellout_time:

            if len(hold_buy_set) == 1:
                
                if price >= hold_buy_set[len(hold_buy_set) - 1] + sellout_area and sellout_25_flag < 5:

                    binance_sell_market_order(client,order_USDT*leverage/price/sellout_divid*len(hold_buy_set))

                    sellout_25_flag = sellout_25_flag + 1


                    print('                                                            ', end = '')
                    print('進場點位:',hold_buy_set[len(hold_buy_set) - 1],',平移區間:',sellout_area)
                    print('                                                            ', end = '')
                    print(sellout_percent *100,'倍,多單獲利',sellout_area,'塊,減碼賣出，目前(',sellout_25_flag,'/',sellout_divid,')',now_time())   

                    sellout_area = round((price * sellout_percent),2) * (sellout_25_flag + 1)
                    if sellout_25_flag >= 1 and sellout_25_flag < 5:
                        print('                                                            ', end = '')
                        print('獲利減碼區間平移到:',hold_buy_set[len(hold_buy_set) - 1] + sellout_area)
                        limit_flag = 0

                    if sellout_25_flag >= 1 and sellout_25_flag == 5:
                        print('                                                            ', end = '')
                        print('出場己達5次，其餘多單等待反轉訊號出場')
                    print('')
                    
            elif len(hold_buy_set) > 1:
                
                if price >= average_hold_buy + sellout_area and sellout_25_flag < 5:

                    binance_sell_market_order(client,sellout_unit*leverage/price/sellout_divid)

                    sellout_25_flag = sellout_25_flag + 1

                    
                    print('                                                            ', end = '')
                    print('平均進場點位:',average_hold_buy,',平移區間:',sellout_area)
                    print('                                                            ', end = '')
                    print(sellout_percent *100,'倍,多單獲利',sellout_area,'塊,減碼賣出，目前(',sellout_25_flag,'/',sellout_divid,')',now_time())   

                    sellout_area = round((price * sellout_percent),2) * (sellout_25_flag + 1)
                    if sellout_25_flag >= 1 and sellout_25_flag < 5:
                        print('                                                            ', end = '')
                        print('獲利減碼區間平移到:',average_hold_buy + sellout_area)
                        limit_flag = 0

                    if sellout_25_flag >= 1 and sellout_25_flag == 5:
                        print('                                                            ', end = '')
                        print('出場己達5次，其餘多單等待反轉訊號出場')
                    print('')
                
            
        elif sell_already == 1 and sellout_25_flag <= sellout_time:

            if len(hold_sell_set) == 1:
                
                if price <= hold_sell_set[len(hold_sell_set) - 1] - sellout_area and sellout_25_flag < 5:

                    binance_buy_market_order(client,order_USDT*leverage/price/sellout_divid*len(hold_sell_set))

                    sellout_25_flag =  sellout_25_flag + 1


                    print('                                                            ', end = '')
                    print('平均進場點位:',hold_sell_set[len(hold_sell_set) - 1],',平移區間:',sellout_area)
                    print('                                                            ', end = '')
                    print(sellout_percent *100,'倍,多單獲利',sellout_area,'塊,減碼賣出，目前(',sellout_25_flag,'/',sellout_divid,')',now_time())    

                    sellout_area = round((price * sellout_percent),2) * (sellout_25_flag + 1)
                    if sellout_25_flag >= 1 and sellout_25_flag < 5:
                        print('                                                            ', end = '')
                        print('獲利減碼區間平移到:',hold_sell_set[len(hold_sell_set) - 1] - sellout_area)
                        limit_flag = 0

                    if sellout_25_flag >= 1 and sellout_25_flag == 5:
                        print('                                                            ', end = '')
                        print('出場己達5次，其餘空單等待反轉訊號出場')
                    print('')
                
            elif len(hold_sell_set) > 1:
                
                if price <= average_hold_sell - sellout_area and sellout_25_flag < 5:

                    binance_buy_market_order(client,sellout_unit*leverage/price/sellout_divid)

                    sellout_25_flag =  sellout_25_flag + 1


                    
                    print('                                                            ', end = '')
                    print('平均進場點位:',average_hold_sell,',平移區間:',sellout_area)
                    print('                                                            ', end = '')
                    print(sellout_percent *100,'倍,多單獲利',sellout_area,'塊,減碼賣出，目前(',sellout_25_flag,'/',sellout_divid,')',now_time())    

                    sellout_area = round((price * sellout_percent),2) * (sellout_25_flag + 1)
                    if sellout_25_flag >= 1 and sellout_25_flag < 5:
                        print('                                                            ', end = '')
                        print('獲利減碼區間平移到:',average_hold_sell - sellout_area)
                        limit_flag = 0

                    if sellout_25_flag >= 1 and sellout_25_flag == 5:
                        print('                                                            ', end = '')
                        print('出場己達5次，其餘空單等待反轉訊號出場')
                    print('')
        '''
                
                
def stop_long_short(): #直接全平倉
    
    global directly_close 
    
    binance_close_position('BUY')
    binance_close_position('SELL')
    client.futures_cancel_all_open_orders(symbol=symbol)
    directly_close = 0
    

def MACD():
    
    close = np.array(kline_close)

    macd, macdsignal, macdhist = talib.MACD(close, fastperiod=12, slowperiod=26, signalperiod=9)

#    return macd, macdsignal, macdhist  
    
    return round(macdhist[118],2)

def SuperTrend(df, atr_period, multiplier):
    
    float_data_c = [float(x) for x in df.close.values]
    float_data_h = [float(x) for x in df.high.values]
    float_data_l = [float(x) for x in df.low.values]

    df['close'] = np.array(float_data_c)
    df['high'] = np.array(float_data_h)
    df['low'] = np.array(float_data_l)
    
    
    high = df['high']
    low = df['low']
    close = df['close']

    # 首先计算ATR
    price_diffs = [high - low, high - close.shift(), close.shift() - low]
    true_range = pd.concat(price_diffs, axis=1)
    true_range = true_range.abs().max(axis=1)
    atr = true_range.ewm(alpha=1 / atr_period, min_periods=atr_period).mean()

#    atr = talib.ATR(df['high'],df['low'], df['close'], atr_period)
    
    #计算超级趋势指标
    hl2 = (high + low) / 2
    final_upperband = hl2 + (multiplier * atr)
    final_lowerband = hl2 - (multiplier * atr)

    st = [True] * len(df) # True代表上行趋势，False代表下行趋势

    
    for i in range(1, len(df.index)):
        curr, prev = i, i - 1
        
        # 如果当前收盘价上传上轨
        if close[curr] > final_upperband[prev]:
            st[curr] = True
        # 当前收盘价下穿下轨
        elif close[curr] < final_lowerband[prev]:
            st[curr] = False
        # 否则趋势延续
            
        else:
            
            st[curr] = st[prev]
            if st[curr] and final_lowerband[curr] < final_lowerband[prev]:
                final_lowerband[curr] = round(final_lowerband[prev],2)
            if not st[curr] and final_upperband[curr] > final_upperband[prev]:
                final_upperband[curr] = round(final_upperband[prev],2)

        # 根据趋势方向分别移除相应的上下轨
        if st[curr]:
            final_upperband[curr] = np.nan
        else:
            final_lowerband[curr] = np.nan
    
    '''
    return pd.DataFrame({
        'Supertrend': st,
        'Final Lowerband': final_lowerband,
        'Final Upperband': final_upperband,
        'close': close,
        'open_time': stamptime2datetime (df['open_time'],len(df))
    }, index=df.index)

    '''
    # len(df)-1: current K
    # len(df)-2: prev K
    return st[len(df)-2],final_lowerband[len(df)-2],final_upperband[len(df)-2]#,stamptime2datetime (df['open_time'],len(df))
        

#    return st[len(df)-1],final_lowerband[len(df)-1],final_upperband[len(df)-1],st[len(df)-2],final_lowerband[len(df)-2],final_upperband[len(df)-2],st[len(df)-3],final_lowerband[len(df)-3],final_upperband[len(df)-3]


def EMA(pd, period):
    
    df = pd
    
    ema = talib.EMA(df['close'],timeperiod = period)
    
    return round(ema[len(ema)-2],2)

def EMA120_check(price):
    
    global HF_EMA120_5k_flag, HF_EMA120_15k_flag 
    
    if buy_5k_already == 1 and buy_already == 0 and price - hold_buy_set[len(hold_buy_set) - 1] > HF_EMA120_5k_check_value:
        
        if HF_EMA120_5k_flag == 0:
            print('目前獲利:',price - hold_buy_set[len(hold_buy_set) - 1],'大於',HF_EMA120_5k_check_value,'塊,HF_EMA120_5k_flag 改為1 ')
        HF_EMA120_5k_flag = 1
        
    elif sell_5k_already == 1 and sell_already == 0 and hold_sell_set[len(hold_sell_set) - 1] - price > HF_EMA120_5k_check_value:
        
        if HF_EMA120_5k_flag == 0:
            print('目前獲利:',hold_sell_set[len(hold_sell_set) - 1] - price,'大於',HF_EMA120_5k_check_value,'塊,HF_EMA120_5k_flag 改為1 ')
        HF_EMA120_5k_flag = 1
        
    elif buy_5k_already == 1 and buy_already == 1 and price - hold_buy_set[len(hold_buy_set) - 1] > HF_EMA120_15k_check_value:
        
        if HF_EMA120_15k_flag == 0:
            print('目前獲利:',price - hold_buy_set[len(hold_buy_set) - 1],'大於',HF_EMA120_15k_check_value,'塊,HF_EMA120_15k_flag 改為1 ')
        HF_EMA120_5k_flag = 0
        HF_EMA120_15k_flag = 1
        
    elif sell_5k_already == 1 and sell_already == 1 and hold_sell_set[len(hold_sell_set) - 1] - price > HF_EMA120_15k_check_value:
        
        if HF_EMA120_15k_flag == 0:
            print('目前獲利:',hold_sell_set[len(hold_sell_set) - 1] - price,'大於',HF_EMA120_15k_check_value,'塊,HF_EMA120_15k_flag 改為1 ')
        HF_EMA120_5k_flag = 0
        HF_EMA120_15k_flag = 1
        
    elif buy_5k_already == 0 and buy_already == 1 and price - hold_buy_set[len(hold_buy_set) - 1] > HF_EMA120_15k_check_value:
        
        if HF_EMA120_15k_flag == 0:
            print('目前獲利:',price - hold_buy_set[len(hold_buy_set) - 1],'大於',HF_EMA120_15k_check_value,'塊,HF_EMA120_15k_flag 改為1 ')
        HF_EMA120_15k_flag = 1
        
    elif sell_5k_already == 0 and sell_already == 1 and hold_sell_set[len(hold_sell_set) - 1] - price > HF_EMA120_15k_check_value:
        
        if HF_EMA120_15k_flag == 0:
            print('目前獲利:',hold_sell_set[len(hold_sell_set) - 1] - price,'大於',HF_EMA120_15k_check_value,'塊,HF_EMA120_15k_flag 改為1 ')
        HF_EMA120_15k_flag = 1
        
        
    
def CCI(pd,length):
    
    df = pd
    
    cci = talib.CCI(df['close'],df['close'], df['close'], timeperiod=length)

#    return cci
    return cci[len(cci)-2]
    
    
def Slow_Stoch(pd,length_k,length_d):
    
    df = pd
    
    slowk, slowd = talib.STOCH(df['high'], df['low'], df['close'], fastk_period=length_k, slowk_period=3, slowk_matype=0, slowd_period=length_d, slowd_matype=0)
    
#    return slowk, slowd
    return slowk[len(slowk)-2], slowd[len(slowd)-2]  #kd多空

def StochRSI(k, d, n, pd):

    global stochRSI_KD, stochRSI_flag, touch_midline
    
    stochRSI_KD = Stoch(RSI(pd), RSI(pd), RSI(pd), k, d, n)
    
    return stochRSI_KD


# StochasticRSI Function
def Stoch(close,high,low, smoothk, smoothd, n):
    lowestlow = pd.Series.rolling(low,window=n,center=False).min()
    highesthigh = pd.Series.rolling(high, window=n, center=False).max()
    K = pd.Series.rolling(100*((close-lowestlow)/(highesthigh-lowestlow)), window=smoothk).mean()
    D = pd.Series.rolling(K, window=smoothd).mean()
    #return K, D
    return K[len(K)-2], D[len(D)-2]


def RSI(pd):
    
    #symbol = coin_symbol
    #start_str = '605minutes ago UTC'
    #start_str ='10685minutes ago UTC'
    #interval_data ='5m'


    #candles = client.futures_historical_klines(symbol = symbol , start_str = start_str, interval = interval_data)
    #df = pd.DataFrame(candles)
    #df.columns=['timestart','open','high','low','close','?','timeend','?','?','?','?','?']
    df = pd
    #df.timestart = [datetime.datetime.fromtimestamp(i/1000) for i in df.timestart.values]
    #df.timeend = [datetime.datetime.fromtimestamp(i/1000) for i in df.timeend.values]

    # Compute RSI after fixing data
    float_data = [float(x) for x in df.close.values]
    np_float_data = np.array(float_data)
    rsi = talib.RSI(np_float_data, 14)
    df['rsi'] = rsi
    
    return df['rsi']
    
    
    
def ATR(timeperiod,ATR_strategy):
      
    global pd_data
    
#    candles = client.futures_historical_klines(symbol = symbol , start_str = start_str, interval = interval_data)
#    df = pd.DataFrame(candles)

    if ATR_strategy == 'UT_5':
        df = UT_5_pd_data
#        print('UT_5')
        
    elif ATR_strategy == 'UT_15':
        df = UT_15_pd_data
#        print('UT_15')
        
    elif ATR_strategy == 'CE':
        df = pd_data
#        print('CE')
#    df.columns=['timestart','open','high','low','close','?','timeend','?','?','?','?','?']

    float_data_c = [float(x) for x in df.close.values]
    float_data_h = [float(x) for x in df.high.values]
    float_data_l = [float(x) for x in df.low.values]

    df['close'] = np.array(float_data_c)
    df['high'] = np.array(float_data_h)
    df['low'] = np.array(float_data_l)

#    print(df['close'])
#    print(df['high'])
#    print(df['low'])

    atr = talib.ATR(df['high'],df['low'], df['close'], timeperiod=timeperiod)

#    atr_str =  'ATR_'+ str(timeperiod)
#    pd_data[atr_str] = atr
    
    return atr    

        
        
def ATRTrailingStop_300(df_close, timeperiod, atr_multiple , strategy_type ):
    
    
    if strategy_type == 'UT_5':
        loss = atr_multiple * ATR(timeperiod,'UT_5')
        
    elif strategy_type == 'UT_15':
        loss = atr_multiple * ATR(timeperiod,'UT_15')    
        
        
    trailing_stop = df_close - loss
  
    for i in range(1, len(trailing_stop)):

        if df_close[i] > trailing_stop[i-1] and df_close[i-1] > trailing_stop[i-1]:
            trailing_stop[i] = max(trailing_stop[i-1], df_close[i] - loss[i])
        elif df_close[i] < trailing_stop[i-1] and df_close[i-1] < trailing_stop[i-1]:
            trailing_stop[i] = min(trailing_stop[i-1], df_close[i] + loss[i])
        elif df_close[i] > trailing_stop[i-1]:
            trailing_stop[i] = df_close[i] - loss[i]
        else:
            trailing_stop[i] = df_close[i] + loss[i]


        
#    pd_data['ATRTrailingStop_300'] = trailing_stop
    
    return trailing_stop
        

def UT_Bot_Alerts(k):
    
    global ATR_1, ATR_300, ema_300, close_300, buy_sell_set,pd_data
    global UT_5k_Buy, UT_5k_Sell
    global UT_15k_Buy, UT_15k_Sell
    global CE_5k_GreenUp_buy, CE_5k_GreenUp_sell, CE_5k_RedUp_buy, CE_5k_RedUp_sell
    global CE_15k_GreenUp_buy, CE_15k_GreenUp_sell, CE_15k_RedUp_buy, CE_15k_RedUp_sell
    global UT_5_pd_data, UT_15_pd_data
    global UT_15k_prev ,UT_15k_curr, UT_5k_prev ,UT_5k_curr
    global last_UT_position
    
    
    #ATR(1)
    #ATR(300)
    #print(pd_data['ATR'])
    
    if k == 5:
        ATR(1,'UT_5')
        UT_5_pd_data['ATRTrailingStop_300'] = ATRTrailingStop_300(UT_5_pd_data['close'], 300, 2, 'UT_5')
        UT_5_pd_data['ema'] = talib.EMA(UT_5_pd_data['close'],2)
        
        
        ATR_300 = []
        ema_300 = []
        close_300 = []
        buy_sell_set = []

#        print('UT_5_pd_data["ATRTrailingStop_300"] =>' ,UT_5_pd_data['ATRTrailingStop_300'])
#        print('UT_5_pd_data["ema"] =>' ,UT_5_pd_data['ema'])

        try:
            '''
            #print('len(pd_data["ema"]):',len(pd_data['ema']))
            for x in range (n-300,len(UT_5_pd_data['ema'])):
                ema_300.append(UT_5_pd_data['ema'][x])
                close_300.append(UT_5_pd_data['close'].iloc[x])
                ATR_300.append(UT_5_pd_data['ATRTrailingStop_300'][x])   

                if UT_5_pd_data['ema'][x] > UT_5_pd_data['ATRTrailingStop_300'][x] and UT_5_pd_data['ema'][x-1] < UT_5_pd_data['ATRTrailingStop_300'][x-1]:
                    buy_sell_set.append('1')

                elif UT_5_pd_data['ema'][x] < UT_5_pd_data['ATRTrailingStop_300'][x] and UT_5_pd_data['ema'][x-1] > UT_5_pd_data['ATRTrailingStop_300'][x-1]:
                    buy_sell_set.append('-1')

                else:
                    buy_sell_set.append('0')
                    
                print(str(x)+'5k-------------------------------------------')
                print("UT_5_pd_data['ema'][x]:",UT_5_pd_data['ema'][x])
                print("UT_5_pd_data['ATRTrailingStop_300'][x]:",UT_5_pd_data['ATRTrailingStop_300'][x])
                print("UT_5_pd_data['ema'][x-1]:",UT_5_pd_data['ema'][x-1])
                print("UT_5_pd_data['ATRTrailingStop_300'][x-1]:",UT_5_pd_data['ATRTrailingStop_300'][x-1])
                print('--------------------------------------------'+str(x)+'5k',now_time())

            '''
            
            print(''+str(k)+'k-------------------------------------------')
#            print("UT_5_pd_data['ema'][",len(UT_5_pd_data['ema']),"-2]:",UT_5_pd_data['ema'][len(UT_5_pd_data['ema'])-2])
            UT_5k_curr = UT_5_pd_data['ATRTrailingStop_300'][len(UT_5_pd_data['ema'])-2]
            print("UT_5_pd_data['ATRTrailingStop_300'][",len(UT_5_pd_data['ema']),"-2]:",UT_5_pd_data['ATRTrailingStop_300'][len(UT_5_pd_data['ema'])-2])
#            print("UT_5_pd_data['ema'][",len(UT_5_pd_data['ema']),"-2]:",UT_5_pd_data['ema'][len(UT_5_pd_data['ema'])-2-1])
            UT_5k_prev = UT_5_pd_data['ATRTrailingStop_300'][len(UT_5_pd_data['ema'])-3]
            print("UT_5_pd_data['ATRTrailingStop_300'][",len(UT_5_pd_data['ema']),"-3]:",UT_5_pd_data['ATRTrailingStop_300'][len(UT_5_pd_data['ema'])-2-1])
            print('--------------------------------------------'+str(k)+'k',now_time())

            last_UT_position = UT_5k_prev

            if UT_5_pd_data['ema'][len(UT_5_pd_data['ema'])-2] > UT_5_pd_data['ATRTrailingStop_300'][len(UT_5_pd_data['ema'])-2] and UT_5_pd_data['ema'][len(UT_5_pd_data['ema'])-2-1] < UT_5_pd_data['ATRTrailingStop_300'][len(UT_5_pd_data['ema'])-2-1]:
                UT_5k_Buy = 1
                
                if CE_continue == 0:
                    CE_5k_GreenUp_buy = 0
                    CE_5k_RedUp_buy = 0

                print('                                                                               ',end = '')   
                print(str(k),'k,UT訊號,多',now_time())
                print('')

            elif UT_5_pd_data['ema'][len(UT_5_pd_data['ema'])-2] < UT_5_pd_data['ATRTrailingStop_300'][len(UT_5_pd_data['ema'])-2] and UT_5_pd_data['ema'][len(UT_5_pd_data['ema'])-2-1] > UT_5_pd_data['ATRTrailingStop_300'][len(UT_5_pd_data['ema'])-2-1]:
                UT_5k_Sell = 1

                if CE_continue == 0:
                    CE_5k_GreenUp_sell = 0
                    CE_5k_RedUp_sell = 0

                print('                                                                               ',end = '')   
                print(str(k),'k,UT訊號,空',now_time())
                print('')

            else:

#                print('                                                                                             '+str(k),'k,UT沒有訊號')
                print('')

        except Exception as e:
            print("UT_Bot_Alerts(5):", e)
            time.sleep(1)
            pass 
        
        
        
    elif k == 15:
        
        ATR(1,'UT_15')
        UT_15_pd_data['ATRTrailingStop_300'] = ATRTrailingStop_300(UT_15_pd_data['close'], 300, 2, 'UT_15')
        UT_15_pd_data['ema'] = talib.EMA(UT_15_pd_data['close'],2)
        

        ATR_300 = []
        ema_300 = []
        close_300 = []
        buy_sell_set = []

        
        
        try:

            print('               '+str(k)+'k-------------------------------------------')
#            print("               UT_15_pd_data['ema'][",len(UT_15_pd_data['ema']),"-2]:",UT_15_pd_data['ema'][len(UT_15_pd_data['ema'])-2])
            UT_15k_curr = UT_15_pd_data['ATRTrailingStop_300'][len(UT_15_pd_data['ema'])-2]
            print("               UT_15_pd_data['ATRTrailingStop_300'][",len(UT_15_pd_data['ema']),"-2]:",UT_15_pd_data['ATRTrailingStop_300'][len(UT_15_pd_data['ema'])-2])
            UT_15k_prev = UT_15_pd_data['ATRTrailingStop_300'][len(UT_15_pd_data['ema'])-3]
#            print("               UT_15_pd_data['ema'][",len(UT_15_pd_data['ema']),"-3]:",UT_15_pd_data['ema'][len(UT_15_pd_data['ema'])-2-1])
            print("               UT_15_pd_data['ATRTrailingStop_300'][",len(UT_15_pd_data['ema']),"-3]:",UT_15_pd_data['ATRTrailingStop_300'][len(UT_15_pd_data['ema'])-2-1])
            print('               --------------------------------------------'+str(k)+'k',now_time())


            if UT_15_pd_data['ema'][len(UT_15_pd_data['ema'])-2] > UT_15_pd_data['ATRTrailingStop_300'][len(UT_15_pd_data['ema'])-2] and UT_15_pd_data['ema'][len(UT_15_pd_data['ema'])-2-1] < UT_15_pd_data['ATRTrailingStop_300'][len(UT_15_pd_data['ema'])-2-1]:
                UT_15k_Buy = 1
                if CE_continue == 0:
                    CE_15k_GreenUp_buy = 0
                    CE_15k_RedUp_buy = 0

#                print('                                                                                        '+str(k),'k,UT訊號,多',now_time())
                print('')

            elif UT_15_pd_data['ema'][len(UT_15_pd_data['ema'])-2] < UT_15_pd_data['ATRTrailingStop_300'][len(UT_15_pd_data['ema'])-2] and UT_15_pd_data['ema'][len(UT_15_pd_data['ema'])-2-1] > UT_15_pd_data['ATRTrailingStop_300'][len(UT_15_pd_data['ema'])-2-1]:
                UT_15k_Sell = 1
                if CE_continue == 0:
                    CE_15k_GreenUp_sell = 0
                    CE_15k_RedUp_sell = 0

#                print('                                                                                        '+str(k),'k,UT訊號,空',now_time())
                print('')

            else:

#                print('                                                                                        '+str(k),'k,UT沒有訊號')
                print('')
                
                
              
                
        except Exception as e:
            print("UT_Bot_Alerts(15):", e)
            time.sleep(1)
            pass 

        
#n = 600
def ChandeliersExit(length,mult,useClose,k):

    global CE_5k_Buy, CE_5k_Sell
    global CE_15k_Buy, CE_15k_Sell
    global global_longStop, global_longStopPrev, global_Shortstop, global_shortStopPrev, prev_flag
    global CE_5k_GreenUp_buy, CE_5k_GreenUp_sell, CE_5k_RedUp_buy, CE_5k_RedUp_sell
    global CE_15k_GreenUp_buy, CE_15k_GreenUp_sell, CE_15k_RedUp_buy, CE_15k_RedUp_sell
    global buy_5k_count, sell_5k_count, last_longStop_position, last_shortStop_position
        
    df_22_close = []    

    longStopPrev = []
    shortStopPrev = []
    longStop_c = []
    shortStop_c = []


    mult_atr = mult * ATR(length,'CE')

#    print('mult_atr = ',mult_atr)

#    print('len(pd_data["close"]) = ',len(pd_data['close']))

#    print('pd_data["close"].iloc[0] = ',pd_data['close'].iloc[0])
#    print('pd_data["close"].iloc[498] = ',pd_data['close'].iloc[498])
#    print('pd_data["close"].iloc[499] = ',pd_data['close'].iloc[499])

#    df_22_close.append(pd_data['close'].iloc[499])

    df_22_close = pd_data['close'].astype(float).iloc[600-22:].tolist()

#    print('df_22_close.append1 = ',df_22_close)    
    
#    for x in range (n-22,len(pd_data['close'])):
#        print(x)
#        df_22_close.append(pd_data['close'].iloc[x])

    
#    print('test_pd_data_last',df_22_close,now_time())

#    print('df_22_close len =',len(df_22_close)  )        # 看有幾列幾欄
#    print('df_22_close =',type(df_22_close))
#    print(df_22_close[:2], df_22_close[-2:])

    # find H and L enter_period max and min
    if useClose == 1: 
        highest = max(df_22_close)
        longStop = highest - mult_atr
#        print('最高:',highest)
        lowest = min(df_22_close)
        shortStop = lowest + mult_atr
#        print('最低:',lowest)

    if prev_flag == 0:
    
        for x in range (n-22,len(longStop)-1):
            longStopPrev.append(round(longStop[x],2))
            global_longStopPrev.append(round(longStop[x],2))
    
        for x in range (n-22,len(longStop)):
            longStop_c.append(round(longStop[x],2))
            global_longStop.append(round(longStop[x],2))
    
    
    if prev_flag == 1:        
        for x in range (n-22,len(longStop)-1):
            longStopPrev.append(round(longStop[x],2))
        for x in range (n-22,len(longStop)):
            longStop_c.append(round(longStop[x],2))
         


    if prev_flag == 0:
    
        for x in range (n-22,len(shortStop)-1):
            shortStopPrev.append(round(shortStop[x],2))
            global_shortStopPrev.append(round(shortStop[x],2))
    
        for x in range (n-22,len(shortStop)):
            shortStop_c.append(round(shortStop[x],2))
            global_shortStop.append(round(shortStop[x],2))
    
    
    if prev_flag == 1:        
        for x in range (n-22,len(shortStop)-1):
            shortStopPrev.append(round(shortStop[x],2))
        for x in range (n-22,len(shortStop)):
            shortStop_c.append(round(shortStop[x],2))
    
    
    #print('\033[32m') 綠
    #print('\033[31m') 紅
    #print('\033[0m') 默認
    print('')
    
    if k == 5:

        print(str(k),'k,(CE)前一根收盤價:',df_22_close[len(df_22_close)-2],end = '')
        print('  ,(longStop)前一根收盤價:',longStop[len(longStop)-2],end = '')
        print('  ,(shortStop)前一根收盤價:',shortStop[len(shortStop)-2])

        last_longStop_position = longStop[len(longStop)-2]
        last_shortStop_position = shortStop[len(shortStop)-2] 

        '''
        if longStop[len(longStop)-1] > shortStop[len(shortStop)-1]: #綠在上

            print('longStop(',str(k),'k,綠上):',longStop[len(longStop)-1],' > shortStop(',str(k),'k,紅下): ',shortStop[len(shortStop)-1],'\033[0m',now_time())

        elif longStop[len(longStop)-1] < shortStop[len(shortStop)-1] and init == 1: #紅在上

            print('longStop(',str(k),'k,綠下):',longStop[len(longStop)-1],' < shortStop(',str(k),'k,紅上): ',shortStop[len(shortStop)-1],'\033[0m',now_time())


          
            
        if df_22_close[len(df_22_close)-2] >= longStop[len(longStop)-1] and df_22_close[len(df_22_close)-2] >= shortStop[len(shortStop)-1] and init == 1:

                if red_5k_continue > 0 and CE_5k_Buy == 0:
                    
                    print('                                                                                             ')
                    print('                                                            CE訊號,多',now_time())
                    CE_5k_Buy = 1
                    CE_5k_Sell = 0
                    
                elif red_5k_continue > 0 and CE_5k_Buy == 1:

                    print('                                                                                             ')
                    print('                                                            CE訊號,多(同邊己多)',now_time())

        elif df_22_close[len(df_22_close)-2] <= longStop[len(longStop)-1] and df_22_close[len(df_22_close)-2] <= shortStop[len(shortStop)-1] and init == 1:
                    

                if black_5k_continue > 0 and CE_5k_Sell == 0:
                    
                    print('                                                                                             ')
                    print('                                                            CE訊號,空',now_time())
                    CE_5k_Buy = 0
                    CE_5k_Sell = 1
                    

                elif black_5k_continue > 0 and CE_5k_Sell == 1:

                    print('                                                                                             ')
                    print('                                                            CE訊號,空(同邊己空)',now_time())

        else:
            
            CE_5k_Buy = 0
            CE_5k_Sell = 0
            
            print('                                                                                             ')
            print('                                                            CE訊號,介於longStop,shortStop 之間',now_time())
        '''

        if last_longStop_position > last_shortStop_position: #綠在上

            print('longStop(',str(k),'k,綠上):',last_longStop_position,' > shortStop(',str(k),'k,紅下): ',last_shortStop_position,'\033[0m',now_time())

        elif last_longStop_position < last_shortStop_position and init == 1: #紅在上

            print('longStop(',str(k),'k,綠下):',last_longStop_position,' < shortStop(',str(k),'k,紅上): ',last_shortStop_position,'\033[0m',now_time())


          
            
        if df_22_close[len(df_22_close)-2] >= last_longStop_position and df_22_close[len(df_22_close)-2] >= last_shortStop_position and init == 1:

                if red_5k_continue > 0 and CE_5k_Buy == 0:
                    
                    print('                                                                                             ')
                    print('                                                            CE訊號,多',now_time())
                    CE_5k_Buy = 1
                    CE_5k_Sell = 0
                    
                elif red_5k_continue > 0 and CE_5k_Buy == 1:

                    print('                                                                                             ')
                    print('                                                            CE訊號,多(同邊己多)',now_time())

        elif df_22_close[len(df_22_close)-2] <= last_longStop_position and df_22_close[len(df_22_close)-2] <= last_shortStop_position and init == 1:
                    

                if black_5k_continue > 0 and CE_5k_Sell == 0:
                    
                    print('                                                                                             ')
                    print('                                                            CE訊號,空',now_time())
                    CE_5k_Buy = 0
                    CE_5k_Sell = 1
                    

                elif black_5k_continue > 0 and CE_5k_Sell == 1:

                    print('                                                                                             ')
                    print('                                                            CE訊號,空(同邊己空)',now_time())

        else:

            if twoSingal_CEUT_buy == 0 and twoSingal_CEUT_sell == 0:
                
                CE_5k_Buy = 0
                CE_5k_Sell = 0
                
                print('                                                                                             ')
                print('                                                            CE訊號,介於longStop,shortStop 之間',now_time())
             
        
def ChandeliersExit_old_1224(length,mult,useClose,k):

    global CE_5k_Buy, CE_5k_Sell
    global CE_15k_Buy, CE_15k_Sell
    global global_longStop, global_longStopPrev, global_Shortstop, global_shortStopPrev, prev_flag
    global CE_5k_GreenUp_buy, CE_5k_GreenUp_sell, CE_5k_RedUp_buy, CE_5k_RedUp_sell
    global CE_15k_GreenUp_buy, CE_15k_GreenUp_sell, CE_15k_RedUp_buy, CE_15k_RedUp_sell
    global buy_5k_count, sell_5k_count
        
    df22_close = []    

    longStopPrev = []
    shortStopPrev = []
    longStop_c = []
    shortStop_c = []

    
    mult_atr = mult * ATR(length,'CE')

    for x in range (n-22,len(pd_data['close'])):
        df22_close.append(pd_data['close'].iloc[x])

    

    # find H and L enter_period max and min
    if useClose == 1: 
        highest = max(df22_close)
        longStop = highest - mult_atr
#        print('最高:',highest)
        lowest = min(df22_close)
        shortStop = lowest + mult_atr
#        print('最低:',lowest)
        


    if prev_flag == 0:
    
        for x in range (n-22,len(longStop)-1):
            longStopPrev.append(round(longStop[x],2))
            global_longStopPrev.append(round(longStop[x],2))
    
        for x in range (n-22,len(longStop)):
            longStop_c.append(round(longStop[x],2))
            global_longStop.append(round(longStop[x],2))
    
    
    if prev_flag == 1:        
        for x in range (n-22,len(longStop)-1):
            longStopPrev.append(round(longStop[x],2))
        for x in range (n-22,len(longStop)):
            longStop_c.append(round(longStop[x],2))
         


    if prev_flag == 0:
    
        for x in range (n-22,len(shortStop)-1):
            shortStopPrev.append(round(shortStop[x],2))
            global_shortStopPrev.append(round(shortStop[x],2))
    
        for x in range (n-22,len(shortStop)):
            shortStop_c.append(round(shortStop[x],2))
            global_shortStop.append(round(shortStop[x],2))
    
    
    if prev_flag == 1:        
        for x in range (n-22,len(shortStop)-1):
            shortStopPrev.append(round(shortStop[x],2))
        for x in range (n-22,len(shortStop)):
            shortStop_c.append(round(shortStop[x],2))
    
    
    #print('\033[32m') 綠
    #print('\033[31m') 紅
    #print('\033[0m') 默認
    print('')
    
    if k == 5:

        print(str(k),'k,前一根收盤價(CE):',df22_close[len(df22_close)-2])
        

        if longStop[len(longStop)-1] > shortStop[len(shortStop)-1]: #綠在上

            print('longStop(',str(k),'k,綠上): \033[32m',longStop[len(longStop)-1],'\033[0m> shortStop(',str(k),'k,紅下): \033[31m',shortStop[len(shortStop)-1],'\033[0m',now_time())



            CE_5k_RedUp_buy = 0
            CE_5k_RedUp_sell = 0

            if df22_close[len(df22_close)-2] >= longStop[len(longStop)-1] and init == 1:

                if red_5k_continue > 0 and CE_5k_GreenUp_buy == 0:
                    
                    print('')
                    print('                                                                               ',end = '') 
                    print('CE訊號,多',now_time())
                    CE_5k_Buy = 1
                    CE_5k_GreenUp_buy = 1
                    CE_5k_GreenUp_sell = 0
                    

                elif red_5k_continue > 0 and CE_5k_GreenUp_buy == 1:
                    
                    if CE_continue == 1:
                        CE_5k_Buy = 1
                        
                    print('')
                    print('                                                                               ',end = '')
                    print('CE訊號,多(同邊己多)',now_time())


            elif df22_close[len(df22_close)-2] <= shortStop[len(shortStop)-1]:

                if black_5k_continue > 0 and CE_5k_GreenUp_sell == 0:
                    
                    print('')
                    print('                                                                               ',end = '')
                    print('CE訊號,空',now_time())
                    CE_5k_Sell = 1
                    CE_5k_GreenUp_sell = 1
                    CE_5k_GreenUp_buy = 0

                elif black_5k_continue > 0 and CE_5k_GreenUp_sell == 1:
                    
                    if CE_continue == 1:
                        CE_5k_Sell = 1
                        
                    print('')
                    print('                                                                               ',end = '')
                    print('CE訊號,空(同邊己空)',now_time())



        elif longStop[len(longStop)-1] < shortStop[len(shortStop)-1] and init == 1: #紅在上

            print('longStop(',str(k),'k,綠下): \033[32m',longStop[len(longStop)-1],'\033[0m< shortStop(',str(k),'k,紅上): \033[31m',shortStop[len(shortStop)-1],'\033[0m',now_time())

            CE_5k_GreenUp_buy = 0
            CE_5k_GreenUp_sell = 0


            if df22_close[len(df22_close)-2] >= shortStop[len(shortStop)-1]:

                if red_5k_continue > 0 and CE_5k_RedUp_buy == 0:

                    print('')
                    print('                                                                               ',end = '')
                    print('CE訊號,多',now_time())
                    CE_5k_Buy = 1
                    CE_5k_RedUp_buy = 1
                    CE_5k_RedUp_sell = 0

                elif red_5k_continue > 0 and CE_5k_RedUp_buy == 1:
                    
                    if CE_continue == 1:
                        CE_5k_Buy = 1
                        
                    print('')
                    print('                                                                               ',end = '')
                    print('CE訊號,多(同邊己多)',now_time())



            elif df22_close[len(df22_close)-2] <= longStop[len(longStop)-1]:

                if black_5k_continue > 0 and CE_5k_RedUp_sell == 0:
                    
                    print('')
                    print('                                                                               ',end = '')
                    print('CE訊號,空',now_time())
                    CE_5k_Sell = 1
                    CE_5k_RedUp_sell = 1
                    CE_5k_RedUp_buy = 0

                elif black_5k_continue > 0 and CE_5k_RedUp_sell == 1:

                    if CE_continue == 1:
                        CE_5k_Sell = 1
                        
                    print('')
                    print('                                                                               ',end = '')
                    print('CE訊號,空(同邊己空)',now_time())

        
        
                    
    elif k == 15:
        
        print('               ',end = '')
        print(str(k),'k,前一根收盤價(CE):',df22_close[len(df22_close)-2])
        
        if longStopPrev[len(longStopPrev)-1] > shortStopPrev[len(shortStopPrev)-1]: #綠在上
            print('               ',end = '')
            print('longStopPrev(',str(k),'k,綠上): \033[32m',longStopPrev[len(longStopPrev)-1],'\033[0m> shortStopPrev(',str(k),'k,紅下): \033[31m',shortStopPrev[len(shortStopPrev)-1],'\033[0m',now_time())



            CE_15k_RedUp_buy = 0
            CE_15k_RedUp_sell = 0

            if df22_close[len(df22_close)-2] >= longStopPrev[len(longStopPrev)-1] and init == 1:

                if red_15k_continue > 0 and CE_15k_GreenUp_buy == 0:
                    
                    print('               ',end = '')
                    print('                                                            CE訊號,多',now_time())
                    CE_15k_Buy = 1
                    CE_15k_GreenUp_buy = 1
                    CE_15k_GreenUp_sell = 0

                elif red_15k_continue > 0 and CE_15k_GreenUp_buy == 1:
                    
                    if CE_continue == 1:
                        CE_15k_Buy = 1
                    print('               ',end = '')
                    print('                                                            CE訊號,多(同邊己多)',now_time())


            elif df22_close[len(df22_close)-2] <= shortStopPrev[len(shortStopPrev)-1]:

                if black_15k_continue > 0 and CE_15k_GreenUp_sell == 0:
                    
                    print('               ',end = '')
                    print('                                                            CE訊號,空',now_time())
                    CE_15k_Sell = 1
                    CE_15k_GreenUp_sell = 1
                    CE_15k_GreenUp_buy = 0

                elif black_15k_continue > 0 and CE_15k_GreenUp_sell == 1:
                    
                    if CE_continue == 1:
                        CE_15k_Sell = 1
                    print('               ',end = '')
                    print('                                                            CE訊號,空(同邊己空)',now_time())



        elif longStopPrev[len(longStopPrev)-1] < shortStopPrev[len(shortStopPrev)-1] and init == 1: #紅在上
            print('               ',end = '')
            print('longStopPrev(',str(k),'k,綠下): \033[32m',longStopPrev[len(longStopPrev)-1],'\033[0m< shortStopPrev(',str(k),'k,紅上): \033[31m',shortStopPrev[len(shortStopPrev)-1],'\033[0m',now_time())

            CE_15k_GreenUp_buy = 0
            CE_15k_GreenUp_sell = 0


            if df22_close[len(df22_close)-2] >= shortStopPrev[len(shortStopPrev)-1]:

                if red_15k_continue > 0 and CE_15k_RedUp_buy == 0:
                    print('               ',end = '')
                    print('                                                            CE訊號,多',now_time())
                    CE_15k_Buy = 1
                    CE_15k_RedUp_buy = 1
                    CE_15k_RedUp_sell = 0

                elif red_15k_continue > 0 and CE_15k_RedUp_buy == 1:
                    
                    if CE_continue == 1:
                        CE_15k_Buy = 1
                    print('               ',end = '')
                    print('                                                            CE訊號,多(同邊己多)',now_time())



            elif df22_close[len(df22_close)-2] <= longStopPrev[len(longStopPrev)-1]:

                if black_15k_continue > 0 and CE_15k_RedUp_sell == 0:
                    print('               ',end = '')
                    print('                                                            CE訊號,空',now_time())
                    CE_15k_Sell = 1
                    CE_15k_RedUp_sell = 1
                    CE_15k_RedUp_buy = 0

                elif black_15k_continue > 0 and CE_15k_RedUp_sell == 1:
                    
                    if CE_continue == 1:
                        CE_15k_Sell = 1
                    print('               ',end = '')
                    print('                                                            CE訊號,空(同邊己空)',now_time())


    print('')
    

def KH():
    
    global kill_head
    
    if stoploss_time >= start_kill_head:
    
        if stoploss_time < 5 + start_kill_head and stoploss_time >= 0:
            kill_head = math.pow(2,stoploss_time - start_kill_head + 1) -1
            print('                                              -----> ',end = '')
            print('Kill haed change to : ',kill_head,'目前餘額為:',get_av_balance(client, time))


        elif stoploss_time >= 5 + start_kill_head:
            record_USDT = get_av_balance(client, time)
            order_USDT = record_USDT/divid_total_money
            print('                                              -----> ',end = '')
            print('Kill haed change to : ',kill_head,'目前餘額為:',record_USDT)

def shoot_trigger(price,k):
    
    global buy_already, sell_already, stop_loss_set, sellout_25_flag 
    global hold_buy_set, hold_sell_set
    global Up_EMA_5k_flag, Down_EMA_5k_flag
    global Up_EMA_15k_flag, Down_EMA_15k_flag, EMA20_5k, EMA20_15k
    global touch_onetime
    global Buy_st, Sell_st
    global Buy_15k_st, Sell_15k_st, touch_ST
    
    if k == 5:
        
        if Csss_5k_Supertrend[0]:
            
            if price < Csss_5k_Supertrend[1] - ST_5k_stoploss_bound and sell_already == 0 :
                
                if buy_already == 1:
                    
                    stoploss_buy_sellout(price)
                    
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(price)
                    sell_already = 1
                    stop_loss_set.append(Csss_5k_Supertrend[1] + ST_5k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Up ST(綠):',Csss_5k_Supertrend[1],'UT:',UT_5k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')多單先平倉再進場空',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(綠)線上(',ST_5k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1]) 

                    sellout_25_flag = 0
                
                elif buy_already == 0:
                    
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(price)
                    sell_already = 1
                    stop_loss_set.append(Csss_5k_Supertrend[1] + ST_5k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Up ST(綠):',Csss_5k_Supertrend[1],'UT:',UT_5k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')進場空',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(綠)線上(',ST_5k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1]) 

                    sellout_25_flag = 0
            
            
            elif price > Csss_5k_Supertrend[1] + ST_5k_stoploss_bound and buy_already == 0 :
                
                if sell_already == 1:
                    
                    stoploss_sell_sellout(price)
                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(price)
                    buy_already = 1
                    stop_loss_set.append(Csss_5k_Supertrend[1] - ST_5k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Down ST(綠):',Csss_5k_Supertrend[1],'UT:',UT_5k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')空單先平倉再進場多',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(綠)線下(',ST_5k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1])

                    sellout_25_flag = 0
                    
                
                elif sell_already == 0:
                    
                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(price)
                    buy_already = 1
                    stop_loss_set.append(Csss_5k_Supertrend[1] - ST_5k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Down ST(綠):',Csss_5k_Supertrend[1],'UT:',UT_5k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')進場多',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(綠)線下(',ST_5k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1])

                    sellout_25_flag = 0

                

        else:
            
            if price > Csss_5k_Supertrend[2] + ST_5k_stoploss_bound and buy_already == 0 :
                
                if sell_already == 1:
                    
                    stoploss_sell_sellout(price)
                    
                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(price)
                    buy_already = 1
                    stop_loss_set.append(Csss_5k_Supertrend[2] - ST_5k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Down ST(紅):',Csss_5k_Supertrend[2],'UT:',UT_5k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')空單先平倉再進場多',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(紅)線下(',ST_5k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1])

                
                elif sell_already == 0:
                
                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(price)
                    buy_already = 1
                    stop_loss_set.append(Csss_5k_Supertrend[2] - ST_5k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Down ST(紅):',Csss_5k_Supertrend[2],'UT:',UT_5k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')進場多',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(紅)線下(',ST_5k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1])

                    sellout_25_flag = 0
                    
            elif price < Csss_5k_Supertrend[2] - ST_5k_stoploss_bound and sell_already == 0 :
                    
                if buy_already == 1:    
                    
                    stoploss_buy_sellout(price)
                    
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(price)
                    sell_already = 1
                    stop_loss_set.append(Csss_5k_Supertrend[2] + ST_5k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Up ST(紅):',Csss_5k_Supertrend[2],'UT:',UT_5k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')多單先平倉再進場空',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(紅)線上(',ST_5k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1]) 

                    sellout_25_flag = 0
                    
                elif buy_already == 0:
                    
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(price)
                    sell_already = 1
                    stop_loss_set.append(Csss_5k_Supertrend[2] + ST_5k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Up ST(紅):',Csss_5k_Supertrend[2],'UT:',UT_5k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')進場空',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(紅)線上(',ST_5k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1]) 

                    sellout_25_flag = 0
                
    
    if k == 15:
        
        if Csss_15k_Supertrend[0]:
            
            if price < Csss_15k_Supertrend[1] - ST_15k_stoploss_bound and sell_already == 0 :
                
                if buy_already == 1:
                    
                    stoploss_buy_sellout(price)
                    
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(price)
                    sell_already = 1
                    stop_loss_set.append(Csss_15k_Supertrend[1] + ST_15k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Up ST(綠):',Csss_15k_Supertrend[1],'UT:',UT_15k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')多單先平倉再進場空',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(綠)線上(',ST_15k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1]) 

                    sellout_25_flag = 0
                
                elif buy_already == 0:
                    
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(price)
                    sell_already = 1
                    stop_loss_set.append(Csss_15k_Supertrend[1] + ST_15k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Up ST(綠):',Csss_15k_Supertrend[1],'UT:',UT_15k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')進場空',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(綠)線上(',ST_15k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1]) 

                    sellout_25_flag = 0
            
            
            elif price > Csss_15k_Supertrend[1] + ST_15k_stoploss_bound and buy_already == 0 :
                
                if sell_already == 1:
                    
                    stoploss_sell_sellout(price)
                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(price)
                    buy_already = 1
                    stop_loss_set.append(Csss_15k_Supertrend[1] - ST_15k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Down ST(綠):',Csss_15k_Supertrend[1],'UT:',UT_15k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')空單先平倉再進場多',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(綠)線下(',ST_15k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1])

                    sellout_25_flag = 0
                    
                
                elif sell_already == 0:
                    
                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(price)
                    buy_already = 1
                    stop_loss_set.append(Csss_15k_Supertrend[1] - ST_15k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Down ST(綠):',Csss_15k_Supertrend[1],'UT:',UT_15k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')進場多',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(綠)線下(',ST_15k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1])

                    sellout_25_flag = 0

                

        else:
            
            if price > Csss_15k_Supertrend[2] + ST_15k_stoploss_bound and buy_already == 0 :
                
                if sell_already == 1:
                    
                    stoploss_sell_sellout(price)
                    
                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(price)
                    buy_already = 1
                    stop_loss_set.append(Csss_15k_Supertrend[2] - ST_15k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Down ST(紅):',Csss_15k_Supertrend[2],'UT:',UT_15k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')空單先平倉再進場多',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(紅)線下(',ST_15k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1])

                
                elif sell_already == 0:
                
                    binance_buy_market_order(client,order_USDT*leverage/price)
                    hold_buy_set.append(price)
                    buy_already = 1
                    stop_loss_set.append(Csss_15k_Supertrend[2] - ST_15k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Down ST(紅):',Csss_15k_Supertrend[2],'UT:',UT_15k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')進場多',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(紅)線下(',ST_15k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1])

                    sellout_25_flag = 0
                    
            elif price < Csss_15k_Supertrend[2] - ST_15k_stoploss_bound and sell_already == 0 :
                    
                if buy_already == 1:    
                    
                    stoploss_buy_sellout(price)
                    
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(price)
                    sell_already = 1
                    stop_loss_set.append(Csss_15k_Supertrend[2] + ST_15k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Up ST(紅):',Csss_15k_Supertrend[2],'UT:',UT_15k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')多單先平倉再進場空',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(紅)線上(',ST_15k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1]) 

                    sellout_25_flag = 0
                    
                elif buy_already == 0:
                    
                    binance_sell_market_order(client,order_USDT*leverage/price)
                    hold_sell_set.append(price)
                    sell_already = 1
                    stop_loss_set.append(Csss_15k_Supertrend[2] + ST_15k_stoploss_bound)
                    update_stoploss()

                    print('')
                    print('                                              -----> ',end = '')
                    print('目前為Up ST(紅):',Csss_15k_Supertrend[2],'UT:',UT_15k_prev)
                    print('                                              -----> ',end = '')
                    print('###### 在價位(',price,')進場空',now_time())
                    print('                                              -----> ',end = '')
                    print('停損位置為ST(紅)線上(',ST_15k_stoploss_bound,')塊:',stop_loss_set[len(stop_loss_set)-1]) 

                    sellout_25_flag = 0
                
                
                
            

                    

                        
                
    
            
            
                    
def total_sellout(price,k):
    
    global half_sellout_5k_flag, stoploss_time, limit_flag, record_profit
    
    if k == 5:
        
        if half_sellout_5k_flag == 0:
            
            if buy_already == 1 and price > hold_buy_set[len(hold_buy_set)-1] + TT_bound + ST_5k_stoploss_bound:
                binance_close_position('SELL')
                stoploss_time = 0
                limit_flag = 0
                clean_all_vareable()
                record_profit = record_profit + abs(price - hold_buy_set[len(hold_buy_set)-1])
                print('')
                print('                                              -----> ',end = '')
                print('目前為多單,停利(',price,')平倉',now_time())
                print('                                              -----> ',end = '')
                print('重新計算連續虧損次數為:',stoploss_time,' ,Killtime:',kill_head)
                

                #half_sellout_5k_flag = 1


            elif sell_already == 1 and price < hold_sell_set[len(hold_sell_set)-1] - TT_bound - ST_5k_stoploss_bound:
                binance_close_position('BUY')
                stoploss_time = 0
                limit_flag = 0
                clean_all_vareable()
                record_profit = record_profit + abs(price - hold_sell_set[len(hold_sell_set)-1])
                print('')
                print('                                              -----> ',end = '')
                print('目前為空單,停利(',price,')平倉',now_time())
                print('                                              -----> ',end = '')
                print('重新計算連續虧損次數為:',stoploss_time,' ,Killtime:',kill_head)
          
                #half_sellout_5k_flag = 1
    
    if k == 15:
        

        if Csss_15k_Supertrend[0] == True:  
            
            if buy_already == 1 and Csss_15k_Supertrend[1] > hold_buy_set[len(hold_buy_set)-1] and price < Csss_15k_Supertrend[1] + 0.5:
                
                binance_close_position('SELL')
                stoploss_time = 0
                limit_flag = 0
                clean_all_vareable()
                record_profit = record_profit + abs(price - hold_buy_set[len(hold_buy_set)-1])
                print('')
                print('                                              -----> ',end = '')
                print('目前為多單,停利(',price,')平倉',now_time())
                print('                                              -----> ',end = '')
                print('重新計算連續虧損次數為:',stoploss_time,' ,Killtime:',kill_head)


            #half_sellout_5k_flag = 1

        if Csss_15k_Supertrend[0] == False:  
            
            if sell_already == 1 and Csss_15k_Supertrend[2] < hold_sell_set[len(hold_sell_set)-1] and price > Csss_15k_Supertrend[2] - 0.5:
                
                binance_close_position('BUY')
                stoploss_time = 0
                limit_flag = 0
                clean_all_vareable()
                record_profit = record_profit + abs(price - hold_sell_set[len(hold_sell_set)-1])
                print('')
                print('                                              -----> ',end = '')
                print('目前為空單,停利(',price,')平倉',now_time())
                print('                                              -----> ',end = '')
                print('重新計算連續虧損次數為:',stoploss_time,' ,Killtime:',kill_head)
                

def limit_BuySell(price,boundary,way):
    
    global limit_BuySell_tp_high, limit_BuySell_tp_low
    
    # True: 做多 找低點，False: 做空 找高點
    if way:
        if limit_BuySell_tp_low == 0:
            limit_BuySell_tp_low = boundary
        
        else:
            
            if price <= limit_BuySell_tp_low:
                print('靠近綠線,更新低點:',price)
                limit_BuySell_tp_low = price

            else:
                print('靠近綠線,拉回進場:',price)
                limit_BuySell_tp_low = 0
                return 1
        
    else:
        if limit_BuySell_tp_high == 0:
            limit_BuySell_tp_high = boundary
            
        else:    
        
            if price >= limit_BuySell_tp_high:
                print('靠近紅線,更新高點:',price)
                limit_BuySell_tp_high = price

            else:
                print('靠近紅線,拉回進場:',price)
                limit_BuySell_tp_high = 0
                return 1
        
        
                
                  

                
def update_stoploss(): #出場停損改依照是否出場
    
    global stop_loss_set
    
    print('')
    print('               ',end = '')
    print('-------> update_stoploss()',now_time())
    
    
    print('')
    
    if bet_5k:
        
        if Csss_5k_Supertrend[0] == True:
            
            if buy_already == 1 :

                print('                                              -----> ',end = '')
                print('ST(綠)線(',round(Csss_5k_Supertrend[1],2) ,') - ',ST_5k_stoploss_bound,',大於目前停損位置:',round(stop_loss_set[len(stop_loss_set)-1],2))
                stop_loss_set[len(stop_loss_set)-1] = Csss_5k_Supertrend[1] - ST_5k_stoploss_bound

                print('                                              -----> ',end = '')
                print('停損位置改為ST(綠)線(',round(stop_loss_set[len(stop_loss_set)-1],2),')')

            elif sell_already == 1 :
                
                print('                                              -----> ',end = '')
                print('ST(綠)線(',round(Csss_5k_Supertrend[1],2) ,') + ',ST_5k_stoploss_bound,',大於目前停損位置:',round(stop_loss_set[len(stop_loss_set)-1],2))
                stop_loss_set[len(stop_loss_set)-1] = Csss_5k_Supertrend[1] + ST_5k_stoploss_bound

                print('                                              -----> ',end = '')
                print('停損位置改為ST(綠)線(',round(stop_loss_set[len(stop_loss_set)-1],2),')')




        elif Csss_5k_Supertrend[0] == False:

            if sell_already == 1:
                
                print('                                              -----> ',end = '')
                print('ST(紅)線(',round(Csss_5k_Supertrend[2],2) ,') + ',ST_5k_stoploss_bound,',小於目前停損位置:',round(stop_loss_set[len(stop_loss_set)-1],2))
                stop_loss_set[len(stop_loss_set)-1] = Csss_5k_Supertrend[2] + ST_5k_stoploss_bound

                print('                                              -----> ',end = '')
                print('停損位置改為ST(紅)線(',round(stop_loss_set[len(stop_loss_set)-1],2),')')

            
            
            elif buy_already == 1:
                
                print('                                              -----> ',end = '')
                print('ST(紅)線(',round(Csss_5k_Supertrend[2],2) ,') - ',ST_5k_stoploss_bound,',小於目前停損位置:',round(stop_loss_set[len(stop_loss_set)-1],2))
                stop_loss_set[len(stop_loss_set)-1] = Csss_5k_Supertrend[2] - ST_5k_stoploss_bound

                print('                                              -----> ',end = '')
                print('停損位置改為ST(紅)線(',round(stop_loss_set[len(stop_loss_set)-1],2),')')

            
        elif buy_already == 1 and sell_already == 1:
            
            print('                                              -----> ',end = '')
            print('目前未進場')
            
            
            
        
    if bet_15k and 0:

        if Csss_15k_Supertrend[0] == True:
            
            if buy_already == 1 :

                print('                                              -----> ',end = '')
                print('ST(綠)線(',round(Csss_15k_Supertrend[1],2) ,') - ',ST_15k_stoploss_bound,',大於目前停損位置:',round(stop_loss_set[len(stop_loss_set)-1],2))
                stop_loss_set[len(stop_loss_set)-1] = Csss_15k_Supertrend[1] - ST_15k_stoploss_bound

                print('                                              -----> ',end = '')
                print('停損位置改為ST(綠)線(',round(stop_loss_set[len(stop_loss_set)-1],2),')')

            elif sell_already == 1 :
                
                print('                                              -----> ',end = '')
                print('ST(綠)線(',round(Csss_15k_Supertrend[1],2) ,') + ',ST_15k_stoploss_bound,',大於目前停損位置:',round(stop_loss_set[len(stop_loss_set)-1],2))
                stop_loss_set[len(stop_loss_set)-1] = Csss_15k_Supertrend[1] + ST_15k_stoploss_bound

                print('                                              -----> ',end = '')
                print('停損位置改為ST(綠)線(',round(stop_loss_set[len(stop_loss_set)-1],2),')')




        elif Csss_15k_Supertrend[0] == False:

            if sell_already == 1:
                
                print('                                              -----> ',end = '')
                print('ST(紅)線(',round(Csss_15k_Supertrend[2],2) ,') + ',ST_15k_stoploss_bound,',小於目前停損位置:',round(stop_loss_set[len(stop_loss_set)-1],2))
                stop_loss_set[len(stop_loss_set)-1] = Csss_15k_Supertrend[2] + ST_15k_stoploss_bound

                print('                                              -----> ',end = '')
                print('停損位置改為ST(紅)線(',round(stop_loss_set[len(stop_loss_set)-1],2),')')

            
            
            elif buy_already == 1:
                
                print('                                              -----> ',end = '')
                print('ST(紅)線(',round(Csss_15k_Supertrend[2],2) ,') - ',ST_15k_stoploss_bound,',小於目前停損位置:',round(stop_loss_set[len(stop_loss_set)-1],2))
                stop_loss_set[len(stop_loss_set)-1] = Csss_15k_Supertrend[2] - ST_15k_stoploss_bound

                print('                                              -----> ',end = '')
                print('停損位置改為ST(紅)線(',round(stop_loss_set[len(stop_loss_set)-1],2),')')

            
        elif buy_already == 1 and sell_already == 1:
            
            print('                                              -----> ',end = '')
            print('目前未進場')

        
        
            
    
    print('')        
    

def recount_redblack():
    
    b = len(hold_buy_set)
    s = len(hold_sell_set)
    
    if b + s == 30:
        
        hold_buy_set = []
        hold_sell_set = []
            

def total_taxrate():
    
    global RB_Total_TaxRate
    
    b = len(hold_buy_set)
    s = len(hold_sell_set)
    
    RB_Total_TaxRate =  (b + s) * RB_TaxRate * order_USDT * leverage         
    
    print('總手續費:', RB_Total_TaxRate)

          

def P1P_After_stoploss_restart_goReturn(bet, price):
    
    global P1P_go_return, P1P_stoploss_flag

    if bet == 1:
    
        if price > EMA120_5k - 1 and P1P_stoploss_flag == -1:
            
            if len(hold_buy_set) == 0 and len(hold_sell_set) == 0 and P1P_go_return == 0 :
    
                P1P_stoploss_flag = 0
                P1P_go_return = 1
    
                print('120ma:',EMA120_5k)
                print('倉位無單,重摸120ma,P1P_go_return改為:',P1P_go_return)
        
        
        elif price < EMA120_5k + 1 and P1P_stoploss_flag == 1:
            
            if len(hold_buy_set) == 0 and len(hold_sell_set) == 0 and P1P_go_return == 0 :
    
                P1P_stoploss_flag = 0
                P1P_go_return = 1
    
                print('120ma:',EMA120_5k)
                print('倉位無單,重摸120ma,P1P_go_return改為:',P1P_go_return)    

            
            
            
            
            
def P1P_Protect_stopProfit(bet,price):  #120 stop profit
    
    global P1P_stopProfit_at_120ma, P1P_go_return_buy, P1P_go_return_sell, P1P_go_return
    
    if bet == 1:
           
        if len(hold_buy_set) > 0:
            
            if price > P1P_EMA120_5k_p1p - round(price * P1P_Boundary_percent/3,2) and P1P_stopProfit_at_120ma == 0:
            
                binance_sell_market_order(client,order_USDT*leverage/price/2)
                
                P1P_stopProfit_at_120ma = 1

                print('                              --->',end = '')
                print('目前價位高於保護摸線區間:',P1P_EMA120_5k_p1p - round(price * P1P_Boundary_percent/3,2),',多單平倉1/2')
                print('                              --->',end = '')
                print('剩餘多單拉回120ma出場')
            
            
            if price < EMA120_5k - 1.5 and P1P_stopProfit_at_120ma == 1:
                
                binance_close_position('SELL') #stop long
                
                P1P_go_return = 1
                
                print('P1P_stopProfit_at_120ma:',P1P_stopProfit_at_120ma,',多單拉回120ma出場')
                
        
        if len(hold_sell_set) > 0:
            
            if price < P1P_EMA120_5k_m1p + round(price * P1P_Boundary_percent/3,2) and P1P_stopProfit_at_120ma == 0:
            
                binance_buy_market_order(client,order_USDT*leverage/price/2)
            
                P1P_stopProfit_at_120ma = 1

                print('                              --->',end = '')
                print('目前價位低於保護摸線區間:',P1P_EMA120_5k_m1p + round(price * P1P_Boundary_percent/3,2),',空單平倉1/2')
                print('                              --->',end = '')
                print('剩餘空單拉回120ma出場')
                
            if price > EMA120_5k + 1.5 and P1P_stopProfit_at_120ma == 1:
            
                binance_close_position('BUY') #stop short
                
                P1P_go_return = 1
                
                print('P1P_stopProfit_at_120ma:',P1P_stopProfit_at_120ma,',空單拉回120ma出場')    
                
        
        
def HF_stopProfit(bet,price):  #120 stop profit
    
    if bet == 1:
           
        if len(hold_buy_set) > 0 and len(hold_buy_set) <= 15 and price > max(EMA_5k_list):
                
            print('目前價位高於max(EMA_5k_list):',max(EMA_5k_list),',多單直接平倉出場')
            binance_close_position('SELL') #stop long


        if len(hold_sell_set) > 0 and len(hold_sell_set) <= 15 and price < min(EMA_5k_list):
                
            print('目前價位低於min(EMA_5k_list):',min(EMA_5k_list),',空單直接平倉出場')
            binance_close_position('BUY') #stop short
            

def CEUT_stopProfit(bet,price):  #120 stop profit
    
    if bet == 1:
           
        if len(hold_buy_set) > 0 and len(hold_buy_set) <= 15 and price > max(EMA_5k_list):
                
            print('目前價位高於max(EMA_5k_list):',max(EMA_5k_list),',多單直接平倉出場')
            binance_close_position('SELL') #stop long


        if len(hold_sell_set) > 0 and len(hold_sell_set) <= 15 and price < min(EMA_5k_list):
                
            print('目前價位低於min(EMA_5k_list):',min(EMA_5k_list),',空單直接平倉出場')
            binance_close_position('BUY') #stop short            
            
boundary_limit_price = 0   
boundary_sellout_price = 0
def boundary_sellout(price, boundary_price, way):
    
    global boundary_limit_price, boundary_sellout_price
    
    if way == 'long':
        
        if boundary_limit_price == 0 and price > boundary_price - RB_close_120ma:
            boundary_limit_price = price

            print('(boundary_sellout)多單接近long_boundary_sellout_condition - ',RB_close_120ma,' 位置')



        if boundary_limit_price != 0:    

            if price > boundary_limit_price:
                boundary_limit_price = price
                boundary_sellout_price = boundary_price - boundary_limit_price
                print('目前接近long_boundary_sellout_condition最高點改成:',boundary_limit_price,'拉回出場點改為:',round(boundary_limit_price - boundary_sellout_price,2))

                return 0

            if price < boundary_limit_price - boundary_sellout_price :
                print('多單目前位置:',price,'從接近(boundary_sellout)',boundary_price,'的最高點:',boundary_limit_price,'拉回:',round(boundary_sellout_price,2),'多單直接全部出場')

                boundary_limit_price = 0
                return 1

    elif way == 'short':
        
        if boundary_limit_price == 0 and price < boundary_price + RB_close_120ma:
            boundary_limit_price = price 
            print('(boundary_sellout)空單接近short_boundary_sellout_condition + ',RB_close_120ma,' 位置')
                
        if boundary_limit_price != 0:

            if price < boundary_limit_price:
                boundary_limit_price = price 
                boundary_sellout_price = boundary_limit_price - boundary_price
                print('目前接近short_boundary_sellout_condition最低點改成:',boundary_limit_price,'拉回出場點改為:',round(boundary_limit_price + boundary_sellout_price,2))

                return 0
            
            if price > boundary_limit_price + boundary_sellout_price :
                print('空單目前位置:',price,'從接近(boundary_sellout)',boundary_price,'的最低點:',boundary_limit_price,'拉回:',round(boundary_sellout_price,2),'空單直接全部出場')

                boundary_limit_price = 0
                return 1

            
def cross_120ma_order(bet,price):
    
    global check_cross2p1p_flag, check_cross2m1p_flag, return_order_flag 
    
    if check_cross2m1p_flag == 1 and price < P1P_EMA120_5k_m1p + 1.5:
        
        binance_buy_market_order(client,order_USDT*leverage/price/2)
        stop_loss_set.append(price - round(price * 0.008,2))
        print('停損點:',stop_loss_set[len(stop_loss_set)-1])
        binance_buy_stop_market()
        hold_buy_set.append(price)
        check_cross2m1p_flag = 0
        return_order_flag = 1
        
        print('                                                                               ',end = '') 
        print('Return訊號,進多單到120ma',now_time())
                    
        
    
    elif check_cross2p1p_flag == 1 and price > P1P_EMA120_5k_p1p - 1.5:
    
        binance_sell_market_order(client,order_USDT*leverage/price/2)
        stop_loss_set.append(price + round(price * 0.008,2))
        print('停損點:',stop_loss_set[len(stop_loss_set)-1])
        binance_sell_stop_market()
        hold_sell_set.append(price)
        check_cross2p1p_flag = 0
        return_order_flag = 1
        
        print('                                                                               ',end = '') 
        print('Return訊號,進空單到120ma',now_time())
                    

def CEUT_cross_120ma_check(bet,price):
    
    global wait2touch_120ma, ceut_shoot_flag, sign_way
    
    time.sleep(1)

    if wait2touch_120ma == 1 and price > EMA120_5k :
        
        print('wait2touch_120ma == 1 and price(',price,') > EMA120_5k (',EMA120_5k,'), (sign_way = ',sign_way,')',now_time())
        
        wait2touch_120ma = 0
        
        print('                                                                               ',end = '') 
        print('摸120ma,重新等待訊號進場',now_time())


    elif wait2touch_120ma == -1 and price < EMA120_5k :

        print('wait2touch_120ma == -1 and price(',price,') < EMA120_5k (',EMA120_5k,'), (sign_way = ',sign_way,')',now_time())
        
        wait2touch_120ma = 0

        print('                                                                               ',end = '') 
        print('摸120ma,重新等待訊號進場',now_time())

         

def cross_120ma_check(bet,price):
    
    global wait2touch_120ma, ceut_shoot_flag, sign_way
    
    time.sleep(1)

    if wait2touch_120ma == 1 and price > EMA120_5k :
        
        print('wait2touch_120ma == 1 and price(',price,') > EMA120_5k (',EMA120_5k,'), (sign_way = ',sign_way,')',now_time())
        if sign_way == 1:

            wait2touch_120ma = 0
            ceut_shoot_flag = 1
            sign_way = 0
            
            print('                                                                               ',end = '') 
            print('摸120ma,等待黑K進場多',now_time())

        elif sign_way == -1:

            if len(hold_sell_set) == 0:
            
                wait2touch_120ma = 0
                ceut_shoot_flag = -1

                print('                                                                               ',end = '') 
                print('摸120ma,等待黑K進場空',now_time())
                
            elif len(hold_sell_set) > 0:
            
                wait2touch_120ma = 0
                ceut_shoot_flag = -1
    
                print('                                                                               ',end = '') 
                print('摸120ma,等待黑K保持空',now_time())
            
            sign_way = 0



    elif wait2touch_120ma == -1 and price < EMA120_5k :

        print('wait2touch_120ma == -1 and price(',price,') < EMA120_5k (',EMA120_5k,'), (sign_way = ',sign_way,')',now_time())
        
        if sign_way == 1:
            
            if len(hold_buy_set) == 0:

                wait2touch_120ma = 0
                ceut_shoot_flag = 1

                print('                                                                               ',end = '') 
                print('摸120ma,等待紅K進場多',now_time())
                
            elif len(hold_buy_set) > 0:

                wait2touch_120ma = 0
                ceut_shoot_flag = 1
                
                print('                                                                               ',end = '') 
                print('摸120ma,等待紅K保持多',now_time())
                
            sign_way = 0
                
            
                

        elif sign_way == -1:

            wait2touch_120ma = 0
            ceut_shoot_flag = -1
            sign_way = 0

            print('                                                                               ',end = '') 
            print('摸120ma,等待紅K進場空',now_time())

def cross_5k_120ma_check(high, low):
    
    global wait2touch_120ma, ceut_shoot_flag, sign_way
    
    buy_bound = 0
    sell_bound = 0
    
    print('')
    if wait2touch_120ma == 1 :
        
        if EMA240_5k < EMA120_5k - 3.5:
            
            buy_bound = 2.5
            print('      ----> ',end ='')
            print('EMA240_5k > EMA120_5k + 3.5,   ---> buy_bound = 2.5')
            
        
        if high > EMA120_5k - buy_bound:
        
            print('wait2touch_120ma == 1 and high(',high,') > EMA120_5k (',EMA120_5k,'), (sign_way = ',sign_way,')',now_time())
            print('')
            if sign_way == 1:

                wait2touch_120ma = 0
                ceut_shoot_flag = 1
                sign_way = 0

                print('                                                                       ',end = '')
                print('最高點過120ma,等待黑K進場多',now_time())

            elif sign_way == -1:

                if len(hold_sell_set) == 0:

                    wait2touch_120ma = 0
                    ceut_shoot_flag = -1

                    print('                                                                       ',end = '')
                    print('最高點過120ma,等待黑K進場空',now_time())

                elif len(hold_sell_set) > 0:

                    wait2touch_120ma = 0
                    ceut_shoot_flag = -1

                    print('                                                                       ',end = '')
                    print('最高點過120ma,等待黑K保持空',now_time())

                sign_way = 0
                
        else:
            
            if sign_way == 1:
                
                print('     ------------> 出buy訊號,等過120ma收黑k做多, last_5k_high = ',last_5k_high)

            elif sign_way == -1:
                
                print('     ------------> 出buy訊號,等過120ma收黑k做空, last_5k_high = ',last_5k_high)

    elif wait2touch_120ma == -1 : 
        
        if EMA240_5k > EMA120_5k + 3.5:
            
            sell_bound = 2.5
            print('      ----> ',end ='')
            print('EMA240_5k < EMA120_5k - 3.5,   ---> sell_bound = 2.5')
        
        if low < EMA120_5k + sell_bound:

            print('wait2touch_120ma == -1 and low(',low,') < EMA120_5k (',EMA120_5k,'), (sign_way = ',sign_way,')',now_time())
            print('')
            
            if sign_way == 1:

                if len(hold_buy_set) == 0:

                    wait2touch_120ma = 0
                    ceut_shoot_flag = 1

                    print('                                                                       ',end = '') 
                    print('最低點破120ma,等待紅K進場多',now_time())

                elif len(hold_buy_set) > 0:

                    wait2touch_120ma = 0
                    ceut_shoot_flag = 1

                    print('                                                                       ',end = '')
                    print('最低點過120ma,等待紅K保持多',now_time())

                sign_way = 0




            elif sign_way == -1:

                wait2touch_120ma = 0
                ceut_shoot_flag = -1
                sign_way = 0

                print('                                                                       ',end = '')
                print('最低點過120ma,等待紅K進場空',now_time())
                
        else:
            
            if sign_way == 1:
            
                print('     ------------> 出sell訊號,等破120ma收紅k做多,last_5k_low = ',last_5k_low)
            
            elif sign_way == -1:
            
                print('     ------------> 出sell訊號,等破120ma收紅k做空,last_5k_low = ',last_5k_low)
            
            
    elif  wait2touch_120ma == 0 :
        
        if ceut_shoot_flag == 0:
            print('     ------------> 目前沒有進場訊號.last_5k_high = ',last_5k_high,'    last_5k_low = ',last_5k_low)
            
        else:
            
            if ceut_shoot_flag == 1:
                
                print('     ------------> 等收紅K,進場做多或續抱多')
            
                
            elif ceut_shoot_flag == -1:
            
                print('     ------------> 等收黑K,進場做空或續抱空')
            
def front_back_price(price, sign):
    
    global first_price, second_price, sign_way, wait2touch_120ma
    
    if sign == 1:
        
        if first_price == 0:
            
            first_price = price 
            print('            ------> 線內first buy訊號')
            print('            ------> 做空方向,等摸120ma',now_time())
            sign_way = -1
            wait2touch_120ma = 1

        else:
            
            second_price = first_price
            first_price = price
            print('            ------> 線內second buy訊號')

            if first_price > second_price:
                print('            ------> 做多方向,等摸120ma',now_time())
                sign_way = 1
                wait2touch_120ma = 1

            elif first_price < second_price:
                print('            ------> 做空方向,等摸120ma',now_time())
                sign_way = -1
                wait2touch_120ma = 1

        
    elif sign == -1:
        
        if first_price == 0:
            first_price = price
            print('            ------> 線內first sell訊號')
            print('            ------> 做多方向,等摸120ma',now_time())
            sign_way = 1
            wait2touch_120ma = -1

        else:
            second_price = first_price
            first_price = price
            print('            ------> 線內second sell訊號')

            if first_price > second_price:
                print('            ------> 做多方向,等摸120ma',now_time())
                sign_way = 1
                wait2touch_120ma = -1

            elif first_price < second_price:
                print('            ------> 做空方向,等摸120ma',now_time())
                sign_way = -1
                wait2touch_120ma = -1 
            
    
            
def limit_120ma_sellout(bet,price):
    
    global high_price, low_price, sellout_price
    global RB_buy_count, RB_sell_count
    global P1P_go_return_buy, P1P_go_return_sell, P1P_go_return
    global RB_close_120ma, hold_buy_set, hold_sell_set, stop_loss_set
    global check_cross2p1p_flag, check_cross2m1p_flag
    
    
    long_sellout_condition = 0
    short_sellout_condition = 0
    
    if bet == 1:
        
        if len(hold_buy_set) > 0 and len(hold_sell_set) == 0 :
            
            long_sellout_condition = EMA120_5k
            
            if high_price == 0 and price > long_sellout_condition - RB_close_120ma:
                high_price = price
                
                print('多單接近long_sellout_condition - ',RB_close_120ma,' 位置')
                
                
                
            if high_price != 0:    
            
                if price > high_price:
                    high_price = price
                    sellout_price = long_sellout_condition - high_price
                    print('目前接近long_sellout_condition最高點改成:',high_price,'拉回出場點改為:',round(high_price - sellout_price,2))



                if price < high_price - sellout_price :
                    print('多單目前位置:',price,'從接近',EMA240_5k,'(EMA240)最高點:',high_price,'拉回:',round(sellout_price,2),'多單直接全部出場')
                    binance_close_position('SELL')
                    
                    time.sleep(0.1)
                    P1P_go_return = 1
                    check_cross2p1p_flag = 1
                    
                    
                    print('               ',end = '')
                    print('等待重新尋找次低點') 
            
                    binance_cancel_limit_order(client,order_id)

                    
            
             
                
        if len(hold_buy_set) == 0 and len(hold_sell_set) > 0 :
            
            short_sellout_condition = EMA120_5k

            if low_price == 0 and price < short_sellout_condition + RB_close_120ma:
                low_price = price 
                print('空單接近short_sellout_condition + ',RB_close_120ma,' 位置')
                
            if low_price != 0:
            
                if price < low_price:
                    low_price = price 
                    sellout_price = low_price - short_sellout_condition
                    print('目前接近short_sellout_condition最低點改成:',low_price,'拉回出場點改為:',round(low_price + sellout_price,2))


                if price > low_price + sellout_price :
                    print('空單目前位置:',price,'從接近',EMA240_5k,'(EMA240)最低點:',low_price,'拉回:',round(sellout_price,2),'空單直接全部出場')
                    binance_close_position('BUY')
                    
                    
                    time.sleep(0.1)
                    P1P_go_return = 1
                    check_cross2m1p_flag = 1


                    print('               ',end = '')
                    print('等待重新尋找次高點')
            
                    binance_cancel_limit_order(client,order_id)
            

def limit_240ma_sellout(bet,price):
    
    global high_price, low_price, sellout_price
    global RB_buy_count, RB_sell_count
    global P1P_go_return_buy, P1P_go_return_sell, P1P_go_return
    global RB_close_120ma, hold_buy_set, hold_sell_set, stop_loss_set
    global order_benefit_1p_flag
    
    
    long_sellout_condition = 0
    short_sellout_condition = 0
    
    if bet == 1:
        
        if len(hold_buy_set) > 0 and len(hold_sell_set) == 0 :
            
            if EMA240_5k >= EMA120_5k:
            
                if order_benefit_1p_flag == 0:
                    long_sellout_condition = EMA240_5k #P1P_EMA120_5k_p1p
                elif order_benefit_1p_flag == 1:
                    long_sellout_condition = EMA120_5k
                    
            else:
                
                long_sellout_condition = EMA120_5k
            
            if EMA240_5k - hold_buy_set[0] > price * 0.015 and order_benefit_1p_flag == 0:
            
                if boundary_sellout(price, hold_buy_set[0]+ (price * 0.01), 'long') == 1:
                    binance_sell_market_order(client,order_USDT*leverage/price/2)
                    P1P_go_return = 1
                    order_benefit_1p_flag = 1
                    print('多單進場位置離Ema240超過1.5%,獲利的1%後出場一半')
            
 
            if high_price == 0 and price > long_sellout_condition - RB_close_120ma:
                high_price = price
                
                print('多單接近long_sellout_condition - ',RB_close_120ma,' 位置')
                
                
                
            if high_price != 0:    
            
                if price > high_price:
                    high_price = price
                    sellout_price = long_sellout_condition - high_price
                    print('目前接近long_sellout_condition最高點改成:',high_price,'拉回出場點改為:',round(high_price - sellout_price,2))



                if price < high_price - sellout_price :
                    print('多單目前位置:',price,'從接近',EMA240_5k,'(EMA240)最高點:',high_price,'拉回:',round(sellout_price,2),'多單直接全部出場')
                    binance_close_position('SELL')
                    
                    time.sleep(0.1)
                    P1P_go_return = 1

                    print('               ',end = '')
                    print('等待重新尋找次低點') 
            
                    binance_cancel_all_futures_order(client)

                    
            
             
                
        if len(hold_buy_set) == 0 and len(hold_sell_set) > 0 :
            
            if EMA240_5k <= EMA120_5k:
            
                if order_benefit_1p_flag == 0:
                    short_sellout_condition = EMA240_5k #P1P_EMA120_5k_p1p
                elif order_benefit_1p_flag == 1:
                    short_sellout_condition = EMA120_5k
                    
            else:
                
                short_sellout_condition = EMA120_5k
            
            if hold_sell_set[0] - EMA240_5k > price * 0.015 and order_benefit_1p_flag == 0:
            
                if boundary_sellout(price, hold_sell_set[0] - (price * 0.01), 'short') == 1:
                    binance_buy_market_order(client,order_USDT*leverage/price/2)
                    P1P_go_return = 1
                    order_benefit_1p_flag = 1
                    print('空單進場位置離Ema240超過1.5%,獲利的1%後出場一半')

            if low_price == 0 and price < short_sellout_condition + RB_close_120ma:
                low_price = price 
                print('空單接近short_sellout_condition + ',RB_close_120ma,' 位置')
                
            if low_price != 0:
            
                if price < low_price:
                    low_price = price 
                    sellout_price = low_price - short_sellout_condition
                    print('目前接近short_sellout_condition最低點改成:',low_price,'拉回出場點改為:',round(low_price + sellout_price,2))


                if price > low_price + sellout_price :
                    print('空單目前位置:',price,'從接近',EMA240_5k,'(EMA240)最低點:',low_price,'拉回:',round(sellout_price,2),'空單直接全部出場')
                    binance_close_position('BUY')
                    
                    
                    time.sleep(0.1)
                    P1P_go_return = 1


                    print('               ',end = '')
                    print('等待重新尋找次高點')
            
                    binance_cancel_all_futures_order(client)

            
                
                
def max_loss_percent(bet,price):
    
    global RB_max_loss_percent
    
    temp = 0
    
    if len(hold_buy_set) > 0:
        
        hold_set_average()
        
        if round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(price - average_hold_buy),4) - (2*RB_Total_TaxRate) < 0:

            temp = round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(price - average_hold_buy),4) - (2*RB_Total_TaxRate)
            
            if temp < RB_max_loss_percent:
                
                RB_max_loss_percent = temp
                print('目前位置:',price,'最大虧損:',round(RB_max_loss_percent,4))
            
    if len(hold_sell_set) > 0:
        
        hold_set_average()
        
        if round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - price),4)- (2*RB_Total_TaxRate) < 0:
    
            temp = round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - price),4)- (2*RB_Total_TaxRate)
            
            if temp < RB_max_loss_percent:
            
                RB_max_loss_percent = temp
                print('目前位置:',price,'最大虧損:',round(RB_max_loss_percent,4))
    
    
    
            
def RB_profit_record(way):
    
    global record_profit, record_loss
    
    print_variable()
    
    if way == 'BUY': #平空單
        
        if P1P_stopProfit_at_120ma == 1:
        
            if round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate) > 0:

                print('前次獲利:',record_profit)
                print('本次獲利:',round((order_USDT/2*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate/2))
                record_profit = record_profit + round((order_USDT/2*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate/2)
                print('累積獲利:',record_profit)
            else:

                print('前次虧損:',record_loss)
                print('本次虧損:',round((order_USDT/2*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate/2))
                record_loss = record_loss + round((order_USDT/2*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate/2)
                print('累積虧損:',record_loss)    
                
        elif P1P_stopProfit_at_120ma == 0:
            
            if round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate) > 0:

                print('前次獲利:',record_profit)
                print('本次獲利:',round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate))
                record_profit = record_profit + round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate)
                print('累積獲利:',record_profit)
            else:

                print('前次虧損:',record_loss)
                print('本次虧損:',round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate))
                record_loss = record_loss + round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate)
                print('累積虧損:',record_loss)  
                
            
    elif way == 'SELL': #平多單
    
        if P1P_stopProfit_at_120ma == 1:
            
            if round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate) > 0:

                print('前次獲利:',record_profit)
                print('本次獲利:',round((order_USDT/2*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate/2))
                record_profit = record_profit + round((order_USDT/2*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate/2)
                print('累積獲利:',record_profit)

            else:

                print('前次虧損:',record_loss)
                print('本次虧損:',round((order_USDT/2*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate/2))
                record_loss = record_loss + round((order_USDT/2*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate/2)
                print('累積虧損:',record_loss)  
                
        elif P1P_stopProfit_at_120ma == 0:
            
            if round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate) > 0:

                print('前次獲利:',record_profit)
                print('本次獲利:',round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate))
                record_profit = record_profit + round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate)
                print('累積獲利:',record_profit)

            else:

                print('前次虧損:',record_loss)
                print('本次虧損:',round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate))
                record_loss = record_loss + round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate)
                print('累積虧損:',record_loss)  
                

def print_variable():
    
    print('record_profit:',record_profit)
    print('record_loss:',record_loss)
    print('order_USDT:',order_USDT)
    print('len(hold_buy_set):',len(hold_buy_set))
    print('len(hold_buy_set):',len(hold_sell_set))
    print('leverage:',leverage)
    print('average_hold_buy:',average_hold_buy)
    print('average_hold_sell:',average_hold_sell)
    print('lastprice:',lastprice)
    print('RB_Total_TaxRate:',RB_Total_TaxRate)


def clean_all_divergence_variable():
    
    global firstPH, secondPH, firstPL, secondPL 
    global firstPH_flag, secondPH_flag, firstPL_flag, secondPL_flag 
    global t_fph, t_sph, t_fpl, t_spl
    global t_fmh, t_smh, t_fml, t_sml
    global firstMH, secondMH, firstML, secondML 
    global firstMH_flag, secondMH_flag, firstML_flag, secondML_flag
    global macd_up2zero_flag, macd_down2zero_flag
    
    firstPH = secondPH = firstPL = secondPL = 0

    firstMH = secondMH = firstML = secondML = 0

    firstPH_flag = secondPH_flag = firstPL_flag = secondPL_flag = 0

    firstMH_flag = secondMH_flag = firstML_flag = secondML_flag = 0

    t_fph = t_sph = t_fpl = t_spl = ''
    
    t_fmh = t_smh = t_fml = t_sml = ''

    macd_up2zero_flag = macd_down2zero_flag = 0
    
    print('                        -----> ',end = '')
    print('清空所有參數重新開始')
    
    
    
def check_second_high_price(high, low, macdist, time):
    
    global firstPH, secondPH, firstPL, secondPL 
    global firstPH_flag, secondPH_flag, firstPL_flag, secondPL_flag 
    global t_fph, t_sph, t_fpl, t_spl
    global t_fmh, t_smh, t_fml, t_sml
    global firstMH, secondMH, firstML, secondML 
    global firstMH_flag, secondMH_flag, firstML_flag, secondML_flag
    global macd_up2zero_flag, macd_down2zero_flag
    
    print('')
    print('------------finding second high price....')
    print('')
    if firstPH_flag == 0:
        if P1P_above_120ma_p == 1 and macdist > macd_s_line and macd_up2zero_flag == 0 and secondPH_flag == 0: #如果前根K最高大於下邊界,macdist > 0.95
            print('出現次高條件,高點高於超過120ma + ',P1P_Boundary_percent*100,'%,MACD,高於',macd_s_line)

            secondPH = high
            secondMH = macdist
            secondPH_flag = 1
            t_sph = time
            t_smh = time
            macd_up2zero_flag = 1
            
            print('記錄次高點:',secondPH,',時間:',t_sph)
            print('記錄MACD:',secondMH,',時間:',t_smh)
            
        else:
            if high > secondPH and macdist >= secondMH and macd_up2zero_flag == 1:

                print('有次高點,但過次高點時,同根k MACD也高於次高MACD,所以更新最高點為次高點')
                secondPH = high
                secondMH = macdist
                t_sph = time
                t_smh = time
                
                print('更新次高點:',secondPH,',時間:',t_sph)
                print('更新MACD:',secondMH,',時間:',t_smh)


            else:
                
                if macdist > secondMH and secondPH_flag == 1 and macd_up2zero_flag == 1:
                    print('出現次高後,MACD未破-0.15,MACD過高更新')
                    secondMH = macdist
                    t_smh = time
                    print('更新MACD:',secondMH,',時間:',t_smh)

                elif high > secondPH and secondPH_flag == 1 and macd_up2zero_flag == 1:
                    print('出現次高後,MACD未破-0.15,高點過高更新')
                    secondPH = high
                    t_sph = time
                    print('更新次高點:',secondPH,',時間:',t_sph)
            
        
    
    if firstPL_flag == 0:
        if P1P_under_120ma_m == 1 and macdist <= -1 * macd_s_line and macd_down2zero_flag == 0 and secondPL_flag == 0: #如果前根K最低小於下邊界 ,macdist < -0.95
            print('出現次低條件,低點低於120ma - ',P1P_Boundary_percent*100,'%,MACD低於',-1 * macd_s_line)

            secondPL = low
            secondML = macdist
            secondPL_flag = 1
            t_spl = time
            t_sml = time
            macd_down2zero_flag = 1
            
            print('記錄次低點:',secondPL,',時間:',t_spl)
            print('記錄MACD:',secondML,',時間:',t_sml)
            
        else:
            
            if low < secondPL and macdist < secondML and macd_down2zero_flag == 1: 
                print('有次低點,但破次低點時,同根k MACD也低於次低MACD,所以更新最低點為次低點')

                secondPL = low
                secondML = macdist
                secondPL_flag = 1
                t_spl = time
                t_sml = time
                
                print('更新次低點:',secondPL,',時間:',t_spl)
                print('更新MACD:',secondML,',時間:',t_sml)
                
            else:
                
                if macdist < secondML and secondPL_flag == 1 and macd_down2zero_flag == 1:
                    print('出現次低後,MACD未過0.15,macd破低更新')
                    secondML = macdist
                    t_sml = time
                    
                    print('記錄MACD:',secondML,',時間:',t_sml)

                elif low < secondPL and secondPL_flag == 1 and macd_down2zero_flag == 1:
                    print('出現次低後,MACD未過0.15,低點破低更新')
                    secondPL = low
                    t_spl = time
                    
                    print('更新次低點:',secondPL,',時間:',t_spl)
            


def find_price_Max_High_Low(high, low, macdist, time):

    global firstPH, secondPH, firstPL, secondPL 
    global firstPH_flag, secondPH_flag, firstPL_flag, secondPL_flag 
    global t_fph, t_sph, t_fpl, t_spl
    global t_fmh, t_smh, t_fml, t_sml
    global firstMH, secondMH, firstML, secondML 
    global firstMH_flag, secondMH_flag, firstML_flag, secondML_flag
    global macd_up2zero_flag, macd_down2zero_flag
    global P1P_go_return 
    
    
    print('')
    print('------------finding first high....')
    print('')
    if high > secondPH and secondPH_flag == 1 and macd_up2zero_flag == 0:
        print('過次高')
        
        if macdist <= secondMH:
            print('當根k,MACD小於次高MACD',end = '')
            if macdist >= macd_f_line:
                firstPH_flag = 1
                secondPH_flag = 0
                firstMH = macdist
                t_fph = time
                print(',且Macdist 大於',macd_f_line,', firstPH_flag 設為 1')
                print('firstMH,第一次設為',macdist)
    #            check_divergence2order(MACD())  
            else:
                print(',但MACD未大於',macd_f_line)
                    
        else:
            print('但Macdist也過次高,背離條件不成立,重新找新高點')
            secondPH = high
            t_sph = time
            secondMH = macdist
            t_smh = time
            macd_up2zero_flag = 1
            
       
    if low < secondPL and secondPL_flag == 1 and macd_down2zero_flag == 0:
        print('破次低')
        
        if macdist >= secondML:
            print('當根k,MACD大於次低MACD',end = '')
            
            if macdist <= -1 * macd_f_line:
                firstPL_flag = 1
                secondPL_flag = 0
                firstML = macdist 
                t_fpl = time
                print(',且Macdist 小於-',macd_f_line,', firstPL_flag 設為 1')
                print('firstML,第一次設為',macdist)
            
#            check_divergence2order(MACD())   
            else:
                print(',但MACD未小於 -',macd_f_line)
            
                    
        else:
            print('但Macdist也破次低,背離條件不成立,重新找新低點')
            secondPL = low
            t_spl = time
            secondML = macdist
            t_sml = time
            macd_down2zero_flag = 1
            
            
        
        
        
                  
                     
def find_MACD_FS_High_Low(macdist,time):
    
    global firstMH, secondMH, firstML, secondML 
    global firstMH_flag, secondMH_flag, firstML_flag, secondML_flag
    global t_fmh, t_smh, t_fml, t_sml

    if P1P_above_120ma_p == 1 and macdist > macd_line:
        print(',且超過120ma,1%,MACD,高於',macd_line)
        if macdist > firstMH:
            
            t_fmh = time
            firstMH_flag = 1

    if P1P_under_120ma_m == 1 and macdist < -0.95:
        print(',且低於120ma,1%,MACD低於',-1*macd_line)
        if macdist < firstML:
            
            t_fml = time
            firstML_flag = 1


def check_divergence2order(high,low,macdist,price,time):
    
    global firstMH, secondMH, firstML, secondML 
    global firstPH_flag, secondPH_flag, firstPL_flag, secondPL_flag 
    global firstMH_flag, secondMH_flag, firstML_flag, secondML_flag
    global macd_up2zero_flag, macd_down2zero_flag
    global P1P_go_return 
    
    print('')
    print('------------finding divergence 2 order....')
    print('')
    
    if firstPH_flag == 1 and secondPH_flag == 0 : #and macdist > 0.5 : #and last_5k_close < EMA5_5k:
        
        if black_5k_continue > 0:
            
            if macdist <= secondMH:
                print('MACD:',macdist,'小於次高MACD:',secondMH)
                print('出現多背離，準備進場空')
#                secondPH_flag = 1



                binance_sell_market_order(client,order_USDT*leverage/price)
                stop_loss_set.append(price + round(price * 0.01,2))
                print('停損點:',stop_loss_set[len(stop_loss_set)-1])
                binance_sell_stop_market()
                hold_sell_set.append(price)
                P1P_go_return = 0

#                print('空單進場,記錄次高點,獲利後重新找新高點')
#                secondPH = high
#                secondMH = macdist
#                macd_up2zero_flag = 1

            else:
                print('MACD:',macdist,'大於次高MACD:',secondMH,' 己不符合背離條件,重新尋找次高點')
                clean_all_divergence_variable()
                check_second_high_price(high, low, macdist, time)
                
                
        elif red_5k_continue > 0:
            
            if macdist > secondMH:
                
                print('MACD:',macdist,'大於次高MACD:',secondMH,' 己不符合背離條件,重新尋找次高點')
                clean_all_divergence_variable()
                check_second_high_price(high, low, macdist, time)
                
            
        

    if firstPL_flag == 1 and secondPH_flag == 0 : #and macdist < -0.5 : #and last_5k_close > EMA5_5k:
        
        if red_5k_continue > 0:
            
            
            if macdist >= secondML:
                print('MACD:',macdist,'大於次低MACD:',secondML)
                print('出現空背離，準備進場多')
#                secondPL_flag = 1


                binance_buy_market_order(client,order_USDT*leverage/price)
                stop_loss_set.append(price - round(price * 0.01,2))
                print('停損點:',stop_loss_set[len(stop_loss_set)-1])
                binance_buy_stop_market()
                hold_buy_set.append(price)
                P1P_go_return = 0


#                print('多單進場,記錄次低點,獲利後重新找新低點')
#                secondPL = low
#                secondML = macdist
#                macd_down2zero_flag = 1

            else:
                print('MACD:',macdist,'小於次低MACD:',secondML,' 己不符合背離條件,重新尋找次低點')
                clean_all_divergence_variable()
                check_second_high_price(high, low, macdist, time)
                
        elif black_5k_continue > 0:
            
            
            if macdist < secondML:
            
                print('MACD:',macdist,'小於次低MACD:',secondML,' 己不符合背離條件,重新尋找次低點')
                clean_all_divergence_variable()
                check_second_high_price(high, low, macdist, time)
                
                
def check_grid_list_high_low_num(checkvalue):
        
    count = 0 
    less_then_sell = []
    more_then_buy = []
        
    if len(hold_buy_set) > 0:
        
        for x in range (0,len(hold_buy_set)):
            if checkvalue > hold_buy_set[x]:
                more_then_buy.append(hold_buy_set[x])

        return more_then_buy
    
        
    elif len(hold_sell_set) > 0:
        
        for x in range (0,len(hold_sell_set)):
            if checkvalue < hold_sell_set[x]:
                less_then_sell.append(hold_sell_set[x])
              
        return less_then_sell
    
    
def Grid_start_stopProfit(bet,price):
    
    global profit_start
    
    if bet == 1:
    
        if len(hold_buy_set) > 4:

            if price > average_hold_buy + round((price * 0.006),2):

                binance_close_position('SELL')
                print('               ',end = '')
                print('多單太多,獲利超過0.6%,先全平倉') 
                profit_start = 0


        elif len(hold_sell_set) > 4:

            if price < average_hold_sell - round((price * 0.006),2):

                binance_close_position('BUY')
                print('               ',end = '')
                print('空單太多,獲利超過0.6%,先全平倉') 
                profit_start = 0

         
                
def Grid_stopProfit_in_1percent(bet,price):
    
    
    if bet == 1:
        
        if len(hold_buy_set) - len(hold_sell_set) < 3 and len(hold_buy_set) - len(hold_sell_set) > 0:
        
            if len(hold_buy_set) - len(hold_sell_set) == 1:
                if price > hold_buy_set[len(hold_buy_set) - 1] + round((price * Grid_stopProfit_percent * 0.01),2):

                    binance_close_position('SELL')
                    print('               ',end = '')
                    print('1單位多單平均獲利超過',Grid_stopProfit_percent,'%,全平倉')

            elif len(hold_buy_set) - len(hold_sell_set) == 2:
                if price > (hold_buy_set[len(hold_buy_set) - 1] + hold_buy_set[len(hold_buy_set) - 2])/2 + round((price * Grid_stopProfit_percent * 0.01),2):

                    binance_close_position('SELL')
                    print('               ',end = '')
                    print('2單位多單平均獲利超過',Grid_stopProfit_percent,'%,全平倉') 
                      

        elif len(hold_sell_set) - len(hold_buy_set) < 3 and len(hold_sell_set) - len(hold_buy_set) > 0:
        
            if len(hold_sell_set) - len(hold_buy_set) == 1:
                if price < hold_sell_set[len(hold_sell_set) - 1] - round((price * Grid_stopProfit_percent * 0.01),2):

                    binance_close_position('BUY')
                    print('               ',end = '')
                    print('1單位空單平均獲利超過',Grid_stopProfit_percent,'%,全平倉') 
                
            elif len(hold_sell_set) - len(hold_buy_set) == 2:
                if price < (hold_sell_set[len(hold_sell_set) - 1] + hold_sell_set[len(hold_sell_set) - 2])/2 - round((price * Grid_stopProfit_percent * 0.01),2):

                    binance_close_position('BUY')
                    print('               ',end = '')
                    print('2單位空單平均獲利超過',Grid_stopProfit_percent,'%,全平倉') 
                

Grid_over_profit_flag = 0 
def Grid_raise_order_stopProfit_over_1percent(bet,price):
    
    global profit_over_1percent, Grid_raise_order, Grid_over_profit_flag
    global CEUT_buy_count, CEUT_sell_count, Grid_sellout_percent, Grid_1percent_return_flag
    global Grid_final_return_position
    global Grid_total_sellout_flag, Grid_total_sellout_high, Grid_total_sellout_low
    
    if bet == 1:
        
        new_return_position = []
    
        if len(hold_buy_set) > 0 and len(Grid_return_position) > 0:

            for x in range (0, len(Grid_return_position)):

                if Grid_final_return_position == 0:
                    
                    if price > Grid_return_position[x] + round((price * 0.0092),2):

                        new_return_position.append(Grid_return_position[x])
                        
                elif Grid_final_return_position != 0:
                
                    if price > Grid_return_position[x] + round((price * 0.0092),2) and price > Grid_final_return_position:
                        
                        new_return_position.append(Grid_return_position[x])
                        

            if len(new_return_position) > 0 and new_return_position[len(new_return_position)-1]  > Grid_final_return_position:

                #if new
                print(new_return_position)
                Grid_final_return_position = new_return_position[len(new_return_position)-1]
                Grid_1percent_return_flag = 1

                print('               ',end = '')
                print('多單:[',Grid_final_return_position,']獲利超過0.92%,Grid_1percent_return_flag改為:',Grid_1percent_return_flag)
                print('               ',end = '')
                print('反轉位置改為:',Grid_final_return_position,' ,時間:',now_time())


        if len(hold_sell_set) > 0 and len(Grid_return_position) > 0:

            for x in range (0, len(Grid_return_position)):
                
                if Grid_final_return_position == 0:
                    
                    if price < Grid_return_position[x] - round((price * 0.0092),2):

                        new_return_position.append(Grid_return_position[x])
                        Grid_final_return_position = hold_sell_set[len(hold_sell_set)-1] + 1
                
                elif Grid_final_return_position != 0:
                    
                    if price < Grid_return_position[x] - round((price * 0.0092),2) and price < Grid_final_return_position:

                        new_return_position.append(Grid_return_position[x])


            if len(new_return_position) > 0 and new_return_position[len(new_return_position)-1] < Grid_final_return_position:
                
                print(new_return_position)
                Grid_final_return_position = new_return_position[len(new_return_position)-1]
                Grid_1percent_return_flag = 1

                print('               ',end = '')
                print('空單:[',Grid_final_return_position,']獲利超過0.92%,Grid_1percent_return_flag改為:',Grid_1percent_return_flag)
                print('               ',end = '')
                print('反轉位置改為:',Grid_final_return_position,' ,時間:',now_time())
                
                
        
        if len(hold_buy_set) > 0 and Grid_raise_order > 0:
            
            if Grid_KH_flag == 1:
                
                if price > hold_buy_set[len(hold_buy_set) - 1] + round((price * Grid_stopProfit_percent * 0.01),2):

                    binance_sell_market_order(client,(order_USDT*leverage/price)*(math.pow(2,Grid_raise_order+1) - Grid_raise_order_percent))
                    print('               ',end = '')
                    print((math.pow(2,Grid_raise_order+1) - Grid_raise_order_percent),'單位多單加碼獲利超過',Grid_stopProfit_percent,'%,加碼部份平倉')
                    Grid_raise_order = 0
                    
            else:
                
                if price > hold_buy_set[len(hold_buy_set) - 1] + round((price * Grid_stopProfit_percent * 0.01),2):
                
                    binance_sell_market_order(client,(order_USDT*leverage/price)*(Grid_raise_order * Grid_raise_order_percent))
                    print('               ',end = '')
                    print(Grid_raise_order,'單位多單加碼獲利超過',Grid_stopProfit_percent,'%,加碼部份平倉')
                    Grid_raise_order = 0
                    

                
        elif len(hold_sell_set) > 0 and Grid_raise_order > 0:
            
            if Grid_KH_flag == 1:
            
                if price < hold_sell_set[len(hold_sell_set) - 1] - round((price * Grid_stopProfit_percent * 0.01),2):

                    binance_buy_market_order(client,(order_USDT*leverage/price)*(math.pow(2,Grid_raise_order+1) - Grid_raise_order_percent))
                    print('               ',end = '')
                    print((math.pow(2,Grid_raise_order+1) - Grid_raise_order_percent),'單位空單加碼獲利超過',Grid_stopProfit_percent,'%,加碼部份全平倉') 
                    Grid_raise_order = 0
    
            else:
            
                if price < hold_sell_set[len(hold_sell_set) - 1] - round((price * Grid_stopProfit_percent * 0.01),2):
        
                    binance_buy_market_order(client,(order_USDT*leverage/price)*(Grid_raise_order * Grid_raise_order_percent))
                    print('               ',end = '')
                    print(Grid_raise_order,'單位空單加碼獲利超過',Grid_stopProfit_percent,'%,加碼部份全平倉') 
                    Grid_raise_order = 0
                    
            
    
        if len(hold_buy_set) > 0 :
            
            if Grid_total_sellout_flag == 0: #7%
                
                if price > hold_buy_set[len(hold_buy_set) - 1] + round((price * 0.01 * Grid_sellout_percent),2):
                
                    print('               ',end = '')
                    print('多單進入',Grid_sellout_percent,'%保護出場位置(price:',end = '')
                    Grid_total_sellout_flag = 1
                    
                    if Grid_1percent_return_flag == 2:
                        Grid_sellout_percent = 2
                    else:
                        Grid_sellout_percent = 7.5
                        
                    Grid_total_sellout_high = price
                    Grid_total_sellout_low = 0
                    
                    print(Grid_total_sellout_high,'),',Grid_sellout_percent,'% 停利點為:',hold_buy_set[len(hold_buy_set) - 1] + round((price * 0.01 * Grid_sellout_percent),2))
                    print('               ',end = '')
                    print('Grid_sellout_percent改為:',Grid_sellout_percent,'%')
                    
            elif Grid_total_sellout_flag == 1:    
                
                if price > Grid_total_sellout_high:
                    Grid_total_sellout_high = price
                    print('目前停利位置:',hold_buy_set[len(hold_buy_set) - 1] + round((price * 0.01 * Grid_sellout_percent),2),end='')
                    print(' ,保護出場位置:',round(Grid_total_sellout_high * 0.9975,2))
                
                if price > hold_buy_set[len(hold_buy_set) - 1] + round((price * 0.01 * Grid_sellout_percent),2):
                
                    print('               ',end = '')
                    print('多單本次獲利超過',round((price - hold_buy_set[len(hold_buy_set) - 1])/price*100,2),'%,直接平倉獲利了結')
                    binance_close_position('SELL')
                    
                    if Grid_1percent_return_flag == 2:
                        if CEUT_buy_count > 1:
                            CEUT_buy_count = 0
                            Grid_1percent_return_flag = 0
                    else:
                        CEUT_buy_count = 0
                        
                    Grid_total_sellout_flag = 0
                    
                    print('               ',end = '')
                    print('重新記算多單訊號,CEUT_buy_count改為:',CEUT_buy_count)
                    print('               ',end = '')
                    print('Grid_sellout_percent改為:',Grid_sellout_percent,'%')
                    binance_cancel_all_futures_order(client)
                    
                elif price < round(Grid_total_sellout_high * 0.9975,2):
                    
                    print('               ',end = '')
                    print('price:',price,' 多單本次保護獲利為:',round((price - hold_buy_set[len(hold_buy_set) - 1])/price*100,2),'%,直接平倉獲利了結')
                    binance_close_position('SELL')
                    
                    if Grid_1percent_return_flag == 2:
                        if CEUT_buy_count > 1:
                            CEUT_buy_count = 0
                            Grid_1percent_return_flag = 0
                    else:
                        CEUT_buy_count = 0
                        
                    Grid_total_sellout_flag = 0
                    
                    print('               ',end = '')
                    print('重新記算多單訊號,CEUT_buy_count改為:',CEUT_buy_count)
                    print('               ',end = '')
                    print('Grid_sellout_percent改為:',Grid_sellout_percent,'%')
                    binance_cancel_all_futures_order(client)
            

        elif len(hold_sell_set) > 0 :
            
            if Grid_total_sellout_flag == 0: #7%
                
                if price < hold_sell_set[len(hold_sell_set) - 1] - round((price * 0.01 * Grid_sellout_percent),2):
                
                    print('               ',end = '')
                    print('空單進入',Grid_sellout_percent,'%保護出場位置(price:',end = '')
                    
                    Grid_total_sellout_flag = 1
                    
                    if Grid_1percent_return_flag == 2:
                        Grid_sellout_percent = 2
                    else:
                        Grid_sellout_percent = 7.5
                        
                    Grid_total_sellout_low = price
                    Grid_total_sellout_high = 0
                    
                    print(Grid_total_sellout_high,'),',Grid_sellout_percent,'% 停利點為:',hold_sell_set[len(hold_sell_set) - 1] - round((price * 0.01 * Grid_sellout_percent),2))
                    print('               ',end = '')
                    print('Grid_sellout_percent改為:',Grid_sellout_percent,'%')
                    
            elif Grid_total_sellout_flag == 1:    
                
                if price < Grid_total_sellout_low:
                    Grid_total_sellout_low = price
                    print('目前停利位置:',hold_sell_set[len(hold_sell_set) - 1] - round((price * 0.01 * Grid_sellout_percent),2),end='')
                    print(' ,保護出場位置:',round(Grid_total_sellout_low * 1.0025,2))
                
                if price < hold_sell_set[len(hold_sell_set) - 1] - round((price * 0.01 * Grid_sellout_percent),2) :
                
                    print('               ',end = '')
                    print('空單本次獲利超過',round((hold_sell_set[len(hold_sell_set) - 1] - price)/price*100,2),'%,直接平倉獲利了結')
                    binance_close_position('BUY')
                    
                    if Grid_1percent_return_flag == 2:
                        if CEUT_sell_count > 1:
                            CEUT_sell_count = 0
                        Grid_1percent_return_flag = 0
                    else:
                        CEUT_sell_count = 0
                    
                    Grid_total_sellout_flag = 0
                    
                    print('               ',end = '')
                    print('重新記算空單訊號,CEUT_sell_count改為:',CEUT_sell_count)
                    print('               ',end = '')
                    print('Grid_sellout_percent改為:',Grid_sellout_percent,'%')
                    binance_cancel_all_futures_order(client)
                
                elif price > round(Grid_total_sellout_low * 1.0025,2):
            
                    print('               ',end = '')
                    print('price:',price,'空單本次保護獲利為:',round((hold_sell_set[len(hold_sell_set) - 1] - price)/price*100,2),'%,直接平倉獲利了結')
                    binance_close_position('BUY')
                    
                    if Grid_1percent_return_flag == 2:
                        if CEUT_sell_count > 1:
                            CEUT_sell_count = 0
                        Grid_1percent_return_flag = 0
                    else:
                        CEUT_sell_count = 0
                        
                    Grid_total_sellout_flag = 0
                    
                    print('               ',end = '')
                    print('重新記算空單訊號,CEUT_sell_count改為:',CEUT_sell_count)
                    print('               ',end = '')
                    print('Grid_sellout_percent改為:',Grid_sellout_percent,'%')
                    binance_cancel_all_futures_order(client)


def Grid_moving_sellout_and_rebuy(bet,price):
    
    global Grid_moving_sellout_flag, Grid_moving_sellout_time
    
    if bet == 1:
        
        if len(hold_buy_set) > 0 and Grid_sellout_percent > 2:
            
            if Grid_moving_sellout_flag >= 0 and Grid_moving_sellout_flag < 10:
                
                if price > hold_buy_set[len(hold_buy_set) - 1] + round((price * (Grid_moving_sellout_flag + 1) * 0.01),2) :

                    binance_sell_market_order(client,(order_USDT*leverage/price/2/10)) # 進場資金的一半,每次 1/10
                    Grid_moving_sellout_flag += 1
                    Grid_moving_sellout_time += 1
                    print('               ',end = '')
                    print('多單獲利超過1%,一半資金平倉1/10')

            if Grid_moving_sellout_flag > 0 :
                
                if price < hold_buy_set[len(hold_buy_set) - 1] + round((price * (Grid_moving_sellout_flag - 1) * 0.01),2) :

                    binance_buy_market_order(client,(order_USDT*leverage/price/2/10)) 
                    Grid_moving_sellout_flag -= 1
                    print('               ',end = '')
                    print('空單拉回超過1%,加碼1/10資金')
                      

        elif len(hold_sell_set) > 0 and Grid_sellout_percent > 2:
            
            if Grid_moving_sellout_flag >= 0 and Grid_moving_sellout_flag < 10:
            
                if price < hold_sell_set[len(hold_sell_set) - 1] - round((price * (Grid_moving_sellout_flag + 1) * 0.01),2):

                    binance_buy_market_order(client,(order_USDT*leverage/price/2/10)) # 進場資金的一半,每次 1/10
                    Grid_moving_sellout_flag += 1
                    Grid_moving_sellout_time += 1
                    print('               ',end = '')
                    print('空單獲利超過1%,一半資金平倉1/10')

            if Grid_moving_sellout_flag > 0:
                
                if price > hold_sell_set[len(hold_sell_set) - 1] - round((price * (Grid_moving_sellout_flag - 1) * 0.01),2):

                    binance_sell_market_order(client,(order_USDT*leverage/price/2/10))
                    Grid_moving_sellout_flag -= 1
                    print('               ',end = '')
                    print('空單拉回超過1%,加碼1/10資金')
                
                
def Grid_4percent_overUT(bet,price):
    
    global Grid_4percent_flag
    
    if bet == 1:
    
        if len(hold_buy_set) > 0 and Grid_4percent_flag == 0:

            if price + 1 > hold_buy_set[0] + round((price * 0.035),2):

                Grid_4percent_flag = 1
                print('               ',end = '')
                print('多單獲利超過3.5%,Grid_4percent_flag 改為:',Grid_4percent_flag) 



        elif len(hold_sell_set) > 0 and Grid_4percent_flag == 0:

            if price - 1 < hold_sell_set[0] - round((price * 0.035),2):

                Grid_4percent_flag = 1
                print('               ',end = '')
                print('空單獲利超過3.5%,Grid_4percent_flag 改為:',Grid_4percent_flag) 




def twoSignal_stop_profit(bet,price):
    
    global twoSignal_05percent_flag, CEUT_buy_count, CEUT_sell_count, targetSingal_buy_high, targetSingal_sell_low
    global save_buy_K_low_between_two_signal, save_sell_K_high_between_two_signal
    
    if bet == 1:
    
        if len(hold_buy_set) > 0 and twoSignal_05percent_flag == 1:

            if price + 1 > hold_buy_set[0] + round((price * 0.005),2):

                binance_close_position('SELL')
                binance_cancel_all_futures_order(client)
                twoSignal_05percent_flag = 0
                
                print('               ',end = '')
                print('多單獲利超過0.5%,twoSignal_05percent_flag 改為:',twoSignal_05percent_flag) 
                CEUT_buy_count = 1
                print('               ',end = '')
                print('CEUT_buy_count 改為:',CEUT_buy_count) 
                print('targetSingal_buy_high:',targetSingal_buy_high,' 改為:', end = '') 
                targetSingal_buy_high = targetSingal_buy_high[-1:] 
                print(targetSingal_buy_high) 
                print('save_buy_K_low_between_two_signal:',save_buy_K_low_between_two_signal,' 改為:', end = '') 
                save_buy_K_low_between_two_signal = save_buy_K_low_between_two_signal[-1:] 
                print(save_buy_K_low_between_two_signal)

        elif len(hold_sell_set) > 0 and twoSignal_05percent_flag == 1:

            if price - 1 < hold_sell_set[0] - round((price * 0.005),2):

                binance_close_position('BUY')
                binance_cancel_all_futures_order(client)
                twoSignal_05percent_flag = 0
                
                print('               ',end = '')
                print('空單獲利超過0.5%,twoSignal_05percent_flag 改為:',twoSignal_05percent_flag) 
                CEUT_sell_count = 1
                print('               ',end = '')
                print('CEUT_sell_count 改為:',CEUT_sell_count) 
                print('targetSingal_sell_low:',targetSingal_sell_low,' 改為:', end = '') 
                targetSingal_sell_low = targetSingal_sell_low[-1:]
                print(targetSingal_sell_low) 
                print('save_sell_K_high_between_two_signal:',save_sell_K_high_between_two_signal,' 改為:', end = '') 
                save_sell_K_high_between_two_signal = save_sell_K_high_between_two_signal[-1:]
                print(save_sell_K_high_between_two_signal) 


def twoSignal_05_stop_profit_continue_3K():
    
    global twoSignal_05percent_flag, CEUT_buy_count, CEUT_sell_count, targetSingal_buy_high, targetSingal_sell_low
    global save_buy_K_low_between_two_signal, save_sell_K_high_between_two_signal
    
    if len(hold_buy_set) > 0 and twoSignal_05percent_flag == 1:

        if black_5k_continue >= 3:

            binance_close_position('SELL')
            binance_cancel_all_futures_order(client)
            twoSignal_05percent_flag = 0
            
            print('               ',end = '')
            print('反手多單連續三根黑K出場,twoSignal_05percent_flag 改為:',twoSignal_05percent_flag) 
            CEUT_buy_count = 1
            print('               ',end = '')
            print('CEUT_buy_count 改為:',CEUT_buy_count) 
            print('targetSingal_buy_high:',targetSingal_buy_high,' 改為:', end = '') 
            targetSingal_buy_high = targetSingal_buy_high[-1:] 
            print(targetSingal_buy_high) 
            print('save_buy_K_low_between_two_signal:',save_buy_K_low_between_two_signal,' 改為:', end = '') 
            save_buy_K_low_between_two_signal = save_buy_K_low_between_two_signal[-1:] 
            print(save_buy_K_low_between_two_signal)

        else:
            
            print('twoSignal_05percent_flag為:',twoSignal_05percent_flag)
            print('反手多單未收連續三根黑K,繼續抱單')

    elif len(hold_sell_set) > 0 and twoSignal_05percent_flag == 1:
        
        if red_5k_continue >= 3:

            binance_close_position('BUY')
            binance_cancel_all_futures_order(client)
            twoSignal_05percent_flag = 0
            
            print('               ',end = '')
            print('反手空單連續三根紅K出場,twoSignal_05percent_flag 改為:',twoSignal_05percent_flag) 
            CEUT_sell_count = 1
            print('               ',end = '')
            print('CEUT_sell_count 改為:',CEUT_sell_count) 
            print('targetSingal_sell_low:',targetSingal_sell_low,' 改為:', end = '') 
            targetSingal_sell_low = targetSingal_sell_low[-1:]
            print(targetSingal_sell_low) 
            print('save_sell_K_high_between_two_signal:',save_sell_K_high_between_two_signal,' 改為:', end = '') 
            save_sell_K_high_between_two_signal = save_sell_K_high_between_two_signal[-1:]
            print(save_sell_K_high_between_two_signal) 

        else:
            
            print('twoSignal_05percent_flag為:',twoSignal_05percent_flag)
            print('反手空單未收連續三根紅K,繼續抱單')
                
                
def print60(s,variable):
    
    print('               ',end = '')
    print(s,variable)
        

def average_order_USDT():
    
    global record_USDT, order_USDT
    
    record_USDT = get_av_balance(client, time)
    order_USDT = record_USDT/divid_total_money        

    
def save_time():

    dt_n = datetime.now()
    
    return dt_n.strftime("%m%d_%H_%M_%S")    
    
    
def clean_save_output():
    
    with open(filename, 'r') as f:
        nb = nbformat.read(f, as_version=4)
    
    time.sleep(3)
    
    with open('output_'+ save_time() + '.txt', 'w') as f:

        for cell in nb.cells:
            if 'outputs' in cell:
                for output in cell['outputs']:
                    if 'text' in output:
                        f.write(output['text'])
                        f.write('\n') 
                        

    time.sleep(3)
    clear_output()
    print('清除輸出,存檔完成',now_time())    

def twoSignal_sellout_position():

    global CEUT_buy_count, CEUT_sell_count, targetSingal_buy_high, targetSingal_sell_low 
    global save_sell_K_high_between_two_signal, save_buy_K_low_between_two_signal, twoSignal_05percent_flag 
    global twoSignal_opposite_signal_flag

    if CEUT_buy_count >= 2 and twoSignal_05percent_flag == 0:
        print('..........目前多單',end = '')
                        
        if len(hold_buy_set) > 0:
            if twoSignal_opposite_signal_flag == 0:
                if last_5k_close < check_twoSignal_high_low_position('low',targetSingal_buy_high[0]) :
                    print('     收K價位',last_5k_close,',低於區間買多訊號低點',check_twoSignal_high_low_position('low',targetSingal_buy_high[0]),',直接平倉')
                    
                    binance_close_position('SELL')
                    binance_cancel_all_futures_order(client)
        
                    if twoSingal_last_signal == 1:
                        targetSingal_sell_low = []
                        save_sell_K_high_between_two_signal = []
                        targetSingal_buy_high = targetSingal_buy_high[1:]
                        CEUT_buy_count = 1
                        
                    
                    elif twoSingal_last_signal == -1:
                        targetSingal_buy_high = []
                        save_buy_K_low_between_two_signal = []
                        CEUT_sell_count = 1
                        
                    twoSignal_05percent_flag = 0
                    
                else:
                    print('     收K價位',last_5k_close,',高於區間買多訊號低點',check_twoSignal_high_low_position('low',targetSingal_buy_high[0]),',繼續抱單')

            elif twoSignal_opposite_signal_flag == 1:

                if last_5k_close < check_twoSignal_high_low_position('low',targetSingal_buy_high[0]) - hold_buy_set[0] * 0.005 :
                    print('     收K價位',last_5k_close,',低於區間買多訊號低點',check_twoSignal_high_low_position('low',targetSingal_buy_high[0]) - hold_buy_set[0] * 0.005,',直接平倉')
                    
                    binance_close_position('SELL')
                    binance_cancel_all_futures_order(client)
        
                    if twoSingal_last_signal == 1:
                        targetSingal_sell_low = []
                        save_sell_K_high_between_two_signal = []
                        targetSingal_buy_high = targetSingal_buy_high[1:]
                        CEUT_buy_count = 1
                        
                    
                    elif twoSingal_last_signal == -1:
                        targetSingal_buy_high = []
                        save_buy_K_low_between_two_signal = []
                        CEUT_sell_count = 1
                        
                    twoSignal_05percent_flag = 0
                    twoSignal_opposite_signal_flag = 0
                    
                else:
                    print('     收K價位',last_5k_close,',高於區間買多訊號低點',check_twoSignal_high_low_position('low',targetSingal_buy_high[0]),',繼續抱單')



    elif CEUT_sell_count >= 2 and twoSignal_05percent_flag == 0:
        print('..........目前空單',end = '')
        
        if len(hold_sell_set) > 0:

            if twoSignal_opposite_signal_flag == 0:
                
                if last_5k_close > check_twoSignal_high_low_position('high',targetSingal_sell_low[0]) :
                    print('收K價位',last_5k_close,',高於區間賣空訊號高點',check_twoSignal_high_low_position('high',targetSingal_sell_low[0]),',直接平倉')
                    
                    binance_close_position('BUY')  
                    binance_cancel_all_futures_order(client)
            
                    if twoSingal_last_signal == 1:
                        targetSingal_sell_low = []
                        save_sell_K_high_between_two_signal = []
                        CEUT_buy_count = 1
                    
                    elif twoSingal_last_signal == -1:
                        targetSingal_buy_high = []
                        save_buy_K_low_between_two_signal = []
                        targetSingal_sell_low = targetSingal_sell_low[1:]
                        CEUT_sell_count = 1
                        
                    twoSignal_05percent_flag = 0
                else:
                    print('收K價位',last_5k_close,',低於區間賣空訊號高點',check_twoSignal_high_low_position('high',targetSingal_sell_low[0]),',繼續抱單')
            
            elif twoSignal_opposite_signal_flag == 1:

                if last_5k_close > check_twoSignal_high_low_position('high',targetSingal_sell_low[0]) + hold_sell_set[0] * 0.005 :
                    print('收K價位',last_5k_close,',高於區間賣空訊號高點',check_twoSignal_high_low_position('high',targetSingal_sell_low[0]) + hold_sell_set[0] * 0.005,',直接平倉')
                    
                    binance_close_position('BUY')  
                    binance_cancel_all_futures_order(client)
            
                    if twoSingal_last_signal == 1:
                        targetSingal_sell_low = []
                        save_sell_K_high_between_two_signal = []
                        CEUT_buy_count = 1
                    
                    elif twoSingal_last_signal == -1:
                        targetSingal_buy_high = []
                        save_buy_K_low_between_two_signal = []
                        targetSingal_sell_low = targetSingal_sell_low[1:]
                        CEUT_sell_count = 1
                        
                    twoSignal_05percent_flag = 0
                    twoSignal_opposite_signal_flag = 0
                    
                else:
                    print('收K價位',last_5k_close,',低於區間賣空訊號高點',check_twoSignal_high_low_position('high',targetSingal_sell_low[0]),',繼續抱單')
            

def check_twoSignal_high_low_position(way,num):

    if way == 'low':

        try:
            
#            return kline_low[kline_high.index(num)]
            
            
            return buy_low[sell_high.index(num)]
        
        except Exception as e:
            print(f'(check_twoSignal_high_low_position)錯誤訊息: {e}') 
            return num
        
    
    elif way == 'high':

        try:
#            return kline_high[kline_low.index(num)]
            return sell_high[buy_low.index(num)]

        except Exception as e:
            print(f'(check_twoSignal_high_low_position)錯誤訊息: {e}') 
            return num
        

def keep_new_twoSignal_list(old_list,signal): 

    print('原來two singal list:',old_list)
    new_list = old_list 
    index = new_list.index(signal)  # 找到5的位置
    new_list = new_list[index:]    # 取從5開始到最後

    print('改為:',new_list)
    return new_list
    
def twoSignal_sellout_change_side_0_5_percent(way):

    global stop_loss_set, hold_buy_set, CEUT_sell_count
    global hold_sell_set, CEUT_buy_count, targetSingal_buy_high, targetSingal_sell_low
    global save_sell_K_high_between_two_signal, save_buy_K_low_between_two_signal

    if way == 'SELL':

        print('雙多訊號收K價位,高於前雙空訊號高點:',check_twoSignal_high_low_position('high',min(targetSingal_sell_low)),',直接平倉反手')
        
        binance_close_position('BUY')
        print('            ------> 雙訊號平倉反手0.5%',now_time())
        binance_cancel_all_futures_order(client)
        
        binance_buy_market_order(client,order_USDT*leverage/lastprice)
        stop_loss_set.append(lastprice - round(lastprice * 0.005,2))
        print('停損:',stop_loss_set[len(stop_loss_set)-1])
        binance_buy_stop_market()
        hold_buy_set.append(lastprice)
        hold_set_average()
        CEUT_sell_count = 0
        save_sell_K_high_between_two_signal = []
        targetSingal_sell_low = []
        print('     ------> sell_count 歸 0 :',CEUT_sell_count)
        print('            ------> 重新進場多',now_time())
    
    elif way == 'BUY':

        binance_close_position('SELL')
        print('            ------> 雙訊號平倉反手0.5%',now_time())
        binance_cancel_all_futures_order(client)

        print('雙空訊號收K價位,低於前雙多訊號低點:',check_twoSignal_high_low_position('low',max(targetSingal_buy_high)),',直接平倉反手')
        
        binance_sell_market_order(client,order_USDT*leverage/lastprice)
        stop_loss_set.append(lastprice + round(lastprice * 0.005,2))
        print('停損:',stop_loss_set[len(stop_loss_set)-1])
        binance_sell_stop_market()
        hold_sell_set.append(lastprice)
        hold_set_average()
        CEUT_buy_count = 0
        save_buy_K_low_between_two_signal = []
        targetSingal_buy_high = []
        print('     ------> buy_count 歸 0 :',CEUT_buy_count)
        print('            ------> 重新進場空',now_time())


def twoSignal_keep_high_low_temp():

    global twoSingal_clean_save_high_low_flag

    twoSingal_clean_save_high_low_flag = 1
#    print('twoSingal_clean_save_high_low_flag 設為: ',twoSingal_clean_save_high_low_flag)
#    print('收K後暫存高低點')


def twoSignal_clean_high_low_temp(num):

    global buy_low, sell_high

    buy_low = buy_low[num:]
    sell_high = sell_high[num:]
    print('移除前面',num,'個high low 記錄')


def twoSignal_moving_close_sellout(bet,price):
    
    global high_price, low_price, sellout_price
    global RB_buy_count, RB_sell_count
    global P1P_go_return_buy, P1P_go_return_sell, P1P_go_return
    global RB_close_120ma, hold_buy_set, hold_sell_set, stop_loss_set
    global check_cross2p1p_flag, check_cross2m1p_flag
    global twoSingal_close_05_sellout
    
    
    long_sellout_condition = 0
    short_sellout_condition = 0
    
    if bet == 1:
        
        if len(hold_buy_set) > 0 and len(hold_sell_set) == 0 and twoSignal_05percent_flag == 1:
            
            long_sellout_condition = hold_buy_set[0] + round((price * 0.005),2)
            
            if high_price == 0 and price > long_sellout_condition - twoSingal_close_05_sellout:
                high_price = price
                
                print('多單接近反手出場點:',long_sellout_condition,') - ',twoSingal_close_05_sellout,' 位置')
                
                
                
            if high_price != 0:    
            
                if price > high_price:
                    high_price = price
                    sellout_price = long_sellout_condition - high_price
                    print('目前接近反手出場點,最高點改成:',high_price,'拉回出場點改為:',round(high_price - sellout_price,2))



                if price < high_price - sellout_price :
                    print('多單目前位置:',price,'從接近',short_sellout_condition,'多單出場點附近:',high_price,'拉回:',round(sellout_price,2),'多單直接全部出場')
                    binance_close_position('SELL')
                    print('------>  多單平倉在:',price)
                    hold_buy_set = []
                    stoploss_set = []
                    time.sleep(0.1)

                    binance_cancel_all_futures_order(client)
                    
            
             
                
        if len(hold_buy_set) == 0 and len(hold_sell_set) > 0 and twoSignal_05percent_flag == 1:
            
            short_sellout_condition = hold_sell_set[0] - round((price * 0.005),2)

            if low_price == 0 and price < short_sellout_condition + twoSingal_close_05_sellout:
                low_price = price 
                print('空單接近反手出場點:',short_sellout_condition,' + ',twoSingal_close_05_sellout,' 位置')
                
            if low_price != 0:
            
                if price < low_price:
                    low_price = price 
                    sellout_price = low_price - short_sellout_condition
                    print('目前接近反手出場點,最低點改成:',low_price,'拉回出場點改為:',round(low_price + sellout_price,2))


                if price > low_price + sellout_price :
                    print('空單目前位置:',price,'從接近',short_sellout_condition,'空單出場點附近:',low_price,'拉回:',round(sellout_price,2),'空單直接全部出場')
                    binance_close_position('BUY')
                    print('------>  空單平倉在:',price)

                    hold_sell_set = []
                    stoploss_set = []
                    time.sleep(0.1)

                    binance_cancel_all_futures_order(client)
                            

    

def sorting_high_low_position(way):

    global targetSingal_buy_high, targetSingal_sell_low
    global twoSignal_2percent_flag
    global twoSignal_last_buy_high_signal, twoSignal_last_sell_low_signal, twoSignal_opposite_signal_flag

    if way == 'BUY':

        if CEUT_buy_count != 2 : 
            targetSingal_buy_high.append(last_5k_high)  #先把新位置加進來 
            print('targetSingal_buy_high:',targetSingal_buy_high) 

        if last_5k_high < twoSignal_last_buy_high_signal:

            twoSignal_opposite_signal_flag = 1
            print('新多單雙訊號位置,比前一個訊號低,twoSignal_opposite_signal_flag,改為:',twoSignal_opposite_signal_flag)
        
        #大到小排列,保留前面兩個,然後再做小到大排序    
        targetSingal_buy_high = sorted(targetSingal_buy_high, reverse=True)[:2]
        print('移除完targetSingal_buy_high:',targetSingal_buy_high)
        targetSingal_buy_high.sort()
        print('再把移除完的targetSingal_buy_high做小到大排序:',targetSingal_buy_high)
        print('目前targetSingal_buy_high最高:',max(targetSingal_buy_high))
        print('目前targetSingal_buy_high最低:',min(targetSingal_buy_high))

        twoSignal_last_buy_high_signal = last_5k_high
        print('目前最高的多單訊號價位:',twoSignal_last_buy_high_signal)

    elif way == 'SELL':

        if CEUT_sell_count != 2 : 
            targetSingal_sell_low.append(last_5k_low)  #先把新位置加進來 
            print('原來targetSingal_sell_low:',targetSingal_sell_low) 

        if last_5k_low > twoSignal_last_sell_low_signal:

           twoSignal_opposite_signal_flag = 1
           print('新空單雙訊號位置,比前一個訊號高,twoSignal_opposite_signal_flag,改為:',twoSignal_opposite_signal_flag)
     

        #小到大排列,保留前面兩個,然後再做大到小排序
        targetSingal_sell_low = sorted(targetSingal_sell_low)[:2]                   
        print('移除完targetSingal_sell_low:',targetSingal_sell_low)
        targetSingal_sell_low.sort(reverse=True)
        print('再把移除完的targetSingal_sell_low做大到小排序:',targetSingal_sell_low)
        print('目前targetSingal_sell_low最高:',max(targetSingal_sell_low))
        print('目前targetSingal_sell_low最低:',min(targetSingal_sell_low))

        twoSignal_last_sell_low_signal = last_5k_low
        print('目前最低的多單訊號價位:',twoSignal_last_sell_low_signal)


twoSignal_pullback_percent = 1.5
def twoSignal_4_percent(price):

    global twoSignal_4percent_flag, twoSignal_4percent_profit_high, twoSignal_4percent_profit_low

    if len(hold_buy_set) > 0 and len(hold_sell_set) == 0:
        if (last_5k_high - hold_buy_set[0])/price * 100 > 4:
            twoSignal_4percent_flag = 1
            if twoSignal_4percent_profit_high == 0:
                twoSignal_4percent_profit_high = last_5k_high
            elif last_5k_high > twoSignal_4percent_profit_high:
                twoSignal_4percent_profit_high = last_5k_high
                
            print('     收K價位',last_5k_close,',獲利超過4%,最高點在:',twoSignal_4percent_profit_high)

        else:
            if (last_5k_high - hold_buy_set[0])/price * 100 > 0 and twoSignal_4percent_flag == 1:
                if twoSignal_4percent_profit_high == 0:
                    twoSignal_4percent_profit_high = last_5k_high
                elif last_5k_high > twoSignal_4percent_profit_high:
                    twoSignal_4percent_profit_high = last_5k_high
                print('     多單最高點在:',twoSignal_4percent_profit_high,',目前獲利:',round((last_5k_high - hold_buy_set[0])/price * 100,2) ,'%',',保利點在:',twoSignal_4percent_profit_high - (hold_buy_set[0] * twoSignal_pullback_percent / 100))

    if len(hold_sell_set) > 0 and len(hold_buy_set) == 0:
        if(hold_sell_set[0] - last_5k_low)/price * 100 > 4:
            twoSignal_4percent_flag = 1
            if twoSignal_4percent_profit_low == 0:
                twoSignal_4percent_profit_low = last_5k_low
            elif last_5k_low < twoSignal_4percent_profit_low:
                twoSignal_4percent_profit_low = last_5k_low
            
            print('     收K價位',last_5k_close,',獲利超過4%,最低點在:',twoSignal_4percent_profit_low)

        else:
            if(hold_sell_set[0] - last_5k_low)/price * 100 > 0 and twoSignal_4percent_flag == 1:
                if twoSignal_4percent_profit_low == 0:
                    twoSignal_4percent_profit_low = last_5k_low
                elif last_5k_low < twoSignal_4percent_profit_low:
                    twoSignal_4percent_profit_low = last_5k_low
                print('     空單最低點在:',twoSignal_4percent_profit_low,',目前獲利:',round((hold_sell_set[0] - last_5k_low)/price * 100,2)  ,'%',',保利點在:',twoSignal_4percent_profit_low + (price * twoSignal_pullback_percent / 100))

                
def twoSignal_pullback_2_percent(bet, price):

    global twoSignal_4percent_flag, twoSignal_4percent_profit_high, twoSignal_4percent_profit_low
    global CEUT_buy_count, CEUT_sell_count, twoSignal_3percent_flag, twoSignal_2percent_flag, twoSingal_last_signal

    if bet == 1:
        
        if len(hold_buy_set) > 0 and len(hold_sell_set) == 0 and twoSignal_4percent_profit_high > 0 and twoSignal_4percent_flag == 1:
    
            if (twoSignal_4percent_profit_high - price)/hold_buy_set[0] * 100 > twoSignal_pullback_percent:
                print('     多單價位',price,',在獲利超過4%後,壓回超過',twoSignal_pullback_percent,'%,直接平倉')
                binance_close_position('SELL')
                binance_cancel_all_futures_order(client)
                clean_sellout_profit_variable()
        
        if len(hold_buy_set) == 0 and len(hold_sell_set) > 0 and twoSignal_4percent_profit_low > 0 and twoSignal_4percent_flag == 1:
            
            if (price - twoSignal_4percent_profit_low )/price * 100 > twoSignal_pullback_percent:
                print('     空單價位',price,',在獲利超過4%後,拉回超過',twoSignal_pullback_percent,'%,直接平倉')
                binance_close_position('BUY')
                binance_cancel_all_futures_order(client)
                clean_sellout_profit_variable()


def twoSignal_3_percent(price):

    global twoSignal_3percent_flag

    if len(hold_buy_set) > 0 and len(hold_sell_set) == 0:
        
        if (last_5k_high - hold_buy_set[0])/hold_buy_set[0] * 100 >= 3 :
            twoSignal_3percent_flag = 1
            print('     多單收K價位',last_5k_close,',獲利超過3%目標點(',hold_buy_set[0]*1.03,')')

        else:
            if (last_5k_high - hold_buy_set[0])/hold_buy_set[0] * 100 > 0: 
            
                if twoSignal_3percent_flag == 1:
                    print('     多單獲利己超過3%目標點(',hold_buy_set[0]*1.03,')')
                else:
                    print('     多單獲利未超過3%目標點(',hold_buy_set[0]*1.03,')')

                
    if len(hold_sell_set) > 0 and len(hold_buy_set) == 0:
        
        if(hold_sell_set[0] - last_5k_low)/hold_sell_set[0] * 100 >= 3:
            twoSignal_3percent_flag = 1
            print('     空單收K價位',last_5k_close,',獲利超過3%目標點(',hold_sell_set[0]*0.97,')')

        else:
            if(hold_sell_set[0] - last_5k_low)/hold_sell_set[0] * 100 > 0 :
                
                if twoSignal_3percent_flag == 1:
                    print('     空單獲利己超過3%目標點(',hold_sell_set[0]*0.97,')')  
                else:
                    print('     空單獲利未超過3%目標點(',hold_sell_set[0]*0.97,')')

def twoSignal_continue_ema_3k(price):

    global twoSignal_3percent_flag, twoSignal_4percent_flag, twoSignal_4percent_profit_high, twoSignal_4percent_profit_low
    global CEUT_buy_count, CEUT_sell_count, targetSingal_buy_high, targetSingal_sell_low
    global twoSignal_2percent_flag, twoSignal_opposite_signal_flag

    if twoSignal_2percent_flag == 1:
        if len(hold_buy_set) > 0 and len(hold_sell_set) == 0 :
    
            if twoSignal_ema5_continue_5k_down >= 3 and black_5k_continue >= 3:
                print('     多單價位',price,',在獲利超過2%後,壓回跌破ema(5),連續3根黑K,直接平倉')
                binance_close_position('SELL') 
                binance_cancel_all_futures_order(client)
#                targetSingal_buy_high = targetSingal_buy_high[1:]
                
                clean_sellout_profit_variable()
        
        if len(hold_buy_set) == 0 and len(hold_sell_set) > 0 :
            
            if twoSignal_ema5_continue_5k_up >= 3 and red_5k_continue >= 3:
                print('     空單價位',price,',在獲利超過2%後,拉回站上ema(5),連續3根紅K,直接平倉')
                binance_close_position('BUY')
                binance_cancel_all_futures_order(client)
#                targetSingal_sell_low = targetSingal_sell_low[1:]
                clean_sellout_profit_variable()

    if twoSignal_3percent_flag == 1:
        if len(hold_buy_set) > 0 and len(hold_sell_set) == 0 :
    
            if twoSignal_ema5_continue_5k_down >= 3 and black_5k_continue >= 3:
                print('     多單價位',price,',在獲利超過3%後,壓回跌破ema(5),連續3根黑K,直接平倉')
                binance_close_position('SELL') 
                binance_cancel_all_futures_order(client)
#                targetSingal_buy_high = targetSingal_buy_high[1:]
                clean_sellout_profit_variable()
        
        if len(hold_buy_set) == 0 and len(hold_sell_set) > 0 :
            
            if twoSignal_ema5_continue_5k_up >= 3 and red_5k_continue >= 3:
                print('     空單價位',price,',在獲利超過3%後,拉回站上ema(5),連續3根紅K,直接平倉')
                binance_close_position('BUY')
                binance_cancel_all_futures_order(client)
#                targetSingal_sell_low = targetSingal_sell_low[1:]
                clean_sellout_profit_variable()





def EMA_n(pd, period,n):
    
    df = pd
    
    ema = talib.EMA(df['close'],timeperiod = period)
    
    return round(ema[len(ema)- n],2)


def twoSignal_ema5_continue_5k():

    global twoSignal_ema5_continue_5k_up, twoSignal_ema5_continue_5k_down
    # EMA_n(pd, period,n): n-1為前幾根

    print('EMA(5):',EMA_n(UT_5_pd_data, 5,2),' 收K在:',last_5k_close)   
    
    if last_5k_close >= EMA_n(UT_5_pd_data, 5,2):
        twoSignal_ema5_continue_5k_down = 0
        twoSignal_ema5_continue_5k_up += 1
        print('目前大於EMA 5 的K數:', twoSignal_ema5_continue_5k_up)

    else:
        twoSignal_ema5_continue_5k_up = 0
        twoSignal_ema5_continue_5k_down += 1
        print('目前小於EMA 5 的K數:', twoSignal_ema5_continue_5k_down)


def twoSignal_2_percent(price):

    global twoSignal_2percent_flag

    if twoSignal_opposite_signal_flag == 1:
        
        if len(hold_buy_set) > 0 and len(hold_sell_set) == 0:
            
            if (last_5k_high - hold_buy_set[0])/hold_buy_set[0] * 100 >= 2 :
                twoSignal_2percent_flag = 1
                print('     多單收K價位',last_5k_close,',獲利超過2%目標點(',hold_buy_set[0]*1.02,')')
    
            else:
                if (last_5k_high - hold_buy_set[0])/hold_buy_set[0] * 100 > 0: 
                
                    if twoSignal_2percent_flag == 1:
                        print('     多單獲利己超過2%目標點(',hold_buy_set[0]*1.02,')')
                    else:
                        print('     多單獲利未超過2%目標點(',hold_buy_set[0]*1.02,')')
    
                    
        if len(hold_sell_set) > 0 and len(hold_buy_set) == 0:
            
            if(hold_sell_set[0] - last_5k_low)/hold_sell_set[0] * 100 >= 2:
                twoSignal_2percent_flag = 1
                print('     空單收K價位',last_5k_close,',獲利超過2%目標點(',hold_sell_set[0]*0.98,')')
    
            else:
                if(hold_sell_set[0] - last_5k_low)/hold_sell_set[0] * 100 > 0 :
                    
                    if twoSignal_2percent_flag == 1:
                        print('     空單獲利己超過2%目標點(',hold_sell_set[0]*0.98,')')  
                    else:
                        print('     空單獲利未超過2%目標點(',hold_sell_set[0]*0.98,')')


def clean_sellout_profit_variable():

    global twoSignal_opposite_signal_flag, targetSingal_buy_high, targetSingal_sell_low
    global twoSignal_2percent_flag, twoSignal_3percent_flag, twoSignal_4percent_flag
    global twoSignal_4percent_profit_high, twoSignal_4percent_profit_low, twoSingal_last_signal
    global CEUT_buy_count, CEUT_sell_count
    
    twoSignal_opposite_signal_flag = 0
    targetSingal_buy_high = []
    targetSingal_sell_low = []
    twoSignal_2percent_flag = 0
    twoSignal_3percent_flag = 0
    twoSignal_4percent_flag = 0
    twoSignal_4percent_profit_high = 0
    twoSignal_4percent_profit_low = 0
    twoSingal_last_signal = 0
    CEUT_buy_count = 0
    CEUT_sell_count = 0


def _3k_continue():

    global red_5k_continue, black_5k_continue

    if red_5k_continue >= 3:
        
        print('     紅K連續3根以上')
        return 1

    elif black_5k_continue >= 3:
        
        print('     黑K連續3根以上')
        return -1


def _longstop_updown():

    if last_5k_close > last_longStop_position:

        print('收K在綠線之上')
        return 1

    elif last_5k_close < last_longStop_position:

        print('收K在綠線之下')
        return -1

    else:

        print('收K等於綠線')
        return 0

def _longstop_updown_continue():

    global longstop_up, longstop_down

    if last_5k_close > last_longStop_position:

        if red_5k_continue > 0:
            longstop_up += 1
            longstop_down = 0
            
        elif black_5k_continue > 0:
            longstop_up = 0
        
        print('收K在綠線之上,up = ',longstop_up,', down =,',longstop_down)
        return 1

    elif last_5k_close < last_longStop_position:

        if black_5k_continue > 0:
            longstop_down += 1
            longstop_up = 0
            
        elif red_5k_continue > 0:
            longstop_down = 0
        
        print('收K在綠線之下,up = ',longstop_up,', down = ,',longstop_down)
        return -1

    else:

        longstop_down = 0
        longstop_up = 0
        
        print('收K等於綠線,up = ',longstop_up,', down = ,',longstop_down)
        return 0


def _UT_updown():

    if last_5k_close > last_UT_position:

        print('          收K在UT之上')
        return 1

    elif last_5k_close < last_UT_position:

        print('          收K在UT之下')
        return -1 
        
    else:

        print('          收K等於UT')
        return 0



def init_function():
    
    global order_USDT, record_USDT, benefit_percent, init,price ,quantity
    global red_5k_continue, black_5k_continue, red_15k_continue, black_15k_continue
    global prev_flag, update_5k_flag , update_15k_flag
    global UT_5k_Buy, UT_5k_Sell, CE_5k_Buy, CE_5k_Sell
    global UT_15k_Buy, UT_15k_Sell, CE_15k_Buy, CE_15k_Sell
    global t_stoploss, sellout_unit
    global Csss_5k_Supertrend, prev_5k_Supertrend
    global Csss_15k_Supertrend, prev_15k_Supertrend
    global EMA5_5k, EMA20_5k, EMA120_5k, EMA240_5k
    global EMA_15k_list, EMA20_15k, EMA60_15k, EMA120_15k, EMA200_15k, EMA169_15k, EMA240_15k
    global P1P_EMA120_5k_p1p, P1P_EMA120_5k_m1p
    global P2P_EMA120_5k_p1p, P2P_EMA120_5k_m1p
    global firstPH, secondPH, firstPL, secondPL 
    global firstMH, secondMH, firstML, secondML 
    global Grid_raise_order_percent, Grid_return_position 
    
    if re_entry_buy == 1:
        
        UT_5k_Buy = 1
        UT_15k_Buy = 1
        CE_5k_Buy = 1
        CE_15k_Buy = 1
        
    elif re_entry_sell == 1:
        
        UT_5k_Sell = 1
        UT_15k_Sell = 1
        CE_5k_Sell = 1
        CE_15k_Sell = 1
    
    #找出上一根K為何
    print('Do init function')

    client.futures_change_leverage(symbol='ETHUSDT', leverage=leverage)    
        
    #print(black_5k_continue,',', red_5k_continue,',',last_5k_close,',',last_5k_open)
    
    if last_5k_close - last_5k_open > 0:
        red_5k_continue = red_5k_continue + 1
        black_5k_continue = 0
        
        
    elif last_5k_close - last_5k_open < 0:
        black_5k_continue = black_5k_continue + 1
        red_5k_continue = 0 
        
    if last_15k_close - last_15k_open > 0:
        red_15k_continue = red_15k_continue + 1
        black_15k_continue = 0
        
        
    elif last_15k_close - last_15k_open < 0:
        black_15k_continue = black_15k_continue + 1
        red_15k_continue = 0 
        
     
    if red_5k_continue > 0:
        print('(5k)---->前為紅K')    
    elif black_5k_continue > 0:    
        print('(5k)---->前為黑K')
    if red_15k_continue > 0:
        print('(15k)---->前為紅K')    
    elif black_15k_continue > 0:    
        print('(15k)---->前為黑K')
        


    record_USDT = get_av_balance(client, time)
    order_USDT = record_USDT/divid_total_money
        
    record_USDT = 288.4
#    record_USDT = get_av_balance(client, time) + contract_balance_buffer
    order_USDT = record_USDT/divid_total_money




    hold_set_average()
    config_reload()
#    KH()
    
    if conpound_flag == 1:
        print('複利中')
    else:
        print('未複利')
    print('未實現獲利:',ur_balance,'錢包總餘額:',mg_balance,'目前最高本金:',record_USDT) 
    print('目前預計下單金額:',round(order_USDT,2) )
    
    print('')
#    t_stoploss.start()
    
    if bet_5k:
        
        UT_Bot_Alerts(5)
        EMA5_5k = EMA(UT_5_pd_data,5)
        EMA20_5k = EMA(UT_5_pd_data,20)
        EMA60_5k = EMA(UT_5_pd_data,60)
        EMA120_5k = EMA(UT_5_pd_data,120)
        EMA169_5k = EMA(UT_5_pd_data,169)
        EMA200_5k = EMA(UT_5_pd_data,200)
        EMA240_5k = EMA(UT_5_pd_data,240)
        EMA_5k_list = [EMA20_5k, EMA60_5k, EMA120_5k, EMA169_5k, EMA200_5k, EMA240_5k]
        P1P_EMA120_5k_p1p = round(EMA120_5k + (lastprice * P1P_Boundary_percent),2)
        P1P_EMA120_5k_m1p = round(EMA120_5k - (lastprice * P1P_Boundary_percent),2)
        P2P_EMA120_5k_p1p = round(EMA120_5k + (lastprice * P2P_Boundary_percent),2)
        P2P_EMA120_5k_m1p = round(EMA120_5k - (lastprice * P2P_Boundary_percent),2)

    
    if bet_15k and 0:
        
        UT_Bot_Alerts(15)
        EMA20_15k = EMA(UT_15_pd_data,20)
        EMA60_15k = EMA(UT_15_pd_data,60)
        EMA120_15k = EMA(UT_15_pd_data,120)
        EMA169_15k = EMA(UT_15_pd_data,169)
        EMA200_15k = EMA(UT_15_pd_data,200)
        EMA240_15k = EMA(UT_15_pd_data,240)
        EMA_15k_list = [EMA20_15k, EMA60_15k, EMA120_15k, EMA169_15k, EMA200_15k,  EMA240_15k]
    
    
    total_taxrate()
    
    if bet_5k:
        print('5k_EMA20:',EMA20_5k, '  ,5k_EMA60:',EMA60_5k, '  ,5k_EMA120:',EMA120_5k)
        print('5k_EMA169:',EMA169_5k, '  ,5k_EMA200:',EMA200_5k, '  ,5k_EMA240:',EMA240_5k)
        print('EMA List(5k):',EMA_5k_list,' 最大:',max(EMA_5k_list),' 最小:',min(EMA_5k_list))
#        print('P1P_EMA120_5k_m1p:',P1P_EMA120_5k_m1p,' P1P_EMA120_5k_p1p:',P1P_EMA120_5k_p1p,' P1P_go_return:',P1P_go_return)
#        print('P2P_EMA120_5k_m1p:',P2P_EMA120_5k_m1p,' P2P_EMA120_5k_p1p:',P2P_EMA120_5k_p1p)
        print('')
        
    if bet_15k and 0:
        print('15k_EMA20:',EMA20_15k, '  ,15k_EMA60:',EMA60_15k, '  ,15k_EMA120:',EMA120_15k)
        print('15k_EMA169:',EMA169_15k, '  ,15k_EMA200:',EMA200_15k, '  ,15k_EMA240:',EMA240_15k)
        print('EMA List(15k):',EMA_15k_list,' 最大:',max(EMA_15k_list),' 最小:',min(EMA_15k_list))
        print('firstPH:',firstPH,' firstPL:',firstPL,' secondPH:',secondPH,' secondPL:',secondPL)
        print('')
    
    prev_5k_Supertrend = Csss_5k_Supertrend = SuperTrend(UT_5_pd_data,10,3)
    prev_15k_Supertrend = Csss_15k_Supertrend = SuperTrend(UT_15_pd_data,10,3)
    init = 1    
    prev_flag = 1
    if Grid_KH_flag == 1:
        Grid_raise_order_percent = 2
#    ChandeliersExit(22,1.85,1,5)    
    print('initial finish------------------------------------------------------------------------------')
#    Grid_return_position = [2968.63, 2938.11]
#test_dependancy = [1234,5678]
def go(client):
    
    global approach_loss_mark, approach_loss_flip_win_count, approach_loss_win_count
    global approach_loss_protect_win_count, approach_flag
    global double_check, benefit, ma_5
    global win_count, lose_count
    global change_k_flag, buy_already, sell_already
    global bound_quantity
    global price, quantity, lastprice
    global fixed_flag, moving_temp
    global hold_buy_set, hold_sell_set, stop_loss_set
    global buy_benefit, sell_benefit, unrealize_profit_flag
    global UT_5k_Buy, UT_5k_Sell, CE_5k_Buy, CE_5k_Sell
    global UT_15k_Buy, UT_15k_Sell, CE_15k_Buy, CE_15k_Sell
    global update_15k_flag ,update_5k_flag
    global buy_5k_count, sell_5k_count, buy_5k_count_flag, sell_5k_count_flag
    global buy_15k_count, sell_15k_count, buy_15k_count_flag, sell_15k_count_flag
    global order_count, order_flag, sellout_bound
    global sellout_25_flag, sellout_50_flag
    global t_stoploss ,sellout_unit
    global buy_line, sell_line
    global Csss_15k_CCI, Csss_15k_Supertrend, Csss_15k_SlowStoch, Csss_15k_StochRSI, prev_15k_Supertrend
    global Csss_5k_CCI, Csss_5k_Supertrend, Csss_5k_SlowStoch, Csss_5k_StochRSI, prev_5k_Supertrend
    global Up_EMA_5k_flag, Down_EMA_5k_flag, Up_EMA_15k_flag, Down_EMA_15k_flag
    global touch_onetime, touch_UTST_area_flag
    global Dont_buy, Dont_sell, middle_in
    global re_buysell_flag
    global Buy_15k_st, Sell_15k_st, touch_ST
    global EMA_5k_list, EMA5_5k, EMA20_5k, EMA60_5k, EMA120_5k, EMA169_5k, EMA200_5k, EMA240_5k
    global buy_5k_already, sell_5k_already, HF_stoploss
    global EMA_15k_list, EMA20_15k, EMA60_15k, EMA120_15k, EMA169_15k, EMA200_15k, EMA240_15k
    global RB_Total_TaxRate, RB_bound, RB_bound_count, RB_red_continue, RB_black_continue
    global RB_hrh_count, RB_lrl_count, RB_over_x_percent_flag, RB_buy_count, RB_sell_count
    global RB_close_120ma, RB_120ma_bound
    global P1P_upper_120ma, P1P_below_120ma, P1P_under_120ma_m
    global P1P_EMA120_5k_p1p, P1P_EMA120_5k_m1p
    global P2P_EMA120_5k_p1p, P2P_EMA120_5k_m1p
    global P1P_above_120ma_p, P1P_under_120ma_p, P1P_above_120ma_m, P1P_under_120ma_m
    global P1P_go_return
    global firstPH, secondPH, firstPL, secondPL 
    global firstMH, secondMH, firstML, secondML 
    global macd_up2zero_flag, macd_down2zero_flag, ceut_continue, wait2touch_120ma, ceut_shoot_flag
    global sign_way, sign_now, first_price, second_price, p1p_stop_sign
#CEUT_P1P
    
    global buy_open_price, sell_open_price
    global profit_start
    global CEUT_buy_count, CEUT_sell_count, Grid_raise_order, Grid_sellout_percent, Grid_last_order_way
    global Grid_4percent_flag, Grid_1percent_return_flag, Grid_return_position
    global Grid_CE_buy_record, Grid_CE_sell_record, Grid_raise_order_flag

#two_signal

    global save_sell_K_high_between_two_signal, save_buy_K_low_between_two_signal, targetSingal_buy_high, targetSingal_sell_low
    global twoSingal_buy_count, twoSingal_sell_count,test_dependancy, twoSingal_last_signal, twoSignal_05percent_flag
    global twoSingal_clean_save_high_low_flag
    global twoSignal_last_buy_high_signal, twoSignal_last_sell_low_signal
    
    min_15 = 0
    
    
    if len(ETH_queue)>0:
        lastprice = ETH_queue.popleft()
        #bound_quantity = 0.1/lastprice
    
#        kline_5m()
#        kline_bot_5m()
    
    if (datetime.now().minute % 5) == 0 and datetime.now().second > 0 and datetime.now().second <= 59 and update_5k_flag == 0 :
    
        while(kline_5m()):
            time.sleep(0.1)
            
        update_5k_flag = 1
        change_k_flag = 1
        if (datetime.now().minute % 15) == 0:
            print('datetime.now().minute % 15 = ',(datetime.now().minute % 15))
            print('datetime.now().second = ',datetime.now().second)
            update_15k_flag  = 1
    
    if (datetime.now().minute % 5) == 4 and datetime.now().second > 50 and datetime.now().second <= 59 and update_5k_flag == 1 :
        
        update_5k_flag = 0
    
    if (datetime.now().minute % 14) == 0 and datetime.now().second > 57 and datetime.now().second <= 59 and update_15k_flag == 1 :
        
        update_15k_flag = 0
        print('(datetime.now().minute % 15) = ',(datetime.now().minute % 15))
        
#    if (datetime.now().minute % 15) == 0  and datetime.now().second >57 and datetime.now().second <= 59 and update_15k_flag == 0:
            
    if (datetime.now().day % 3) == 0 and (datetime.now().hour) == 13 and (datetime.now().minute) == 58 and (datetime.now().second ) == 0:
    

        clean_save_output()         
        
        
    
    if init == 0:

#        kline_5m()
#        kline_bot_15m(600)
#        kline_UT_5m(1500)
#        kline_UT_15m(1500)

        kline_5m()
        kline_bot_15m(499)
        kline_UT_5m(622)
        kline_UT_15m(499)
        
        init_function()
        
#    stoploss_sellout(1,0) 
#    in_de_crease_order(0)
#    sellout_25_50(1)
    
    if change_k_flag == 1 :
        
        print('')
        print('<----------------------------換K---------------------------->')
        
        while(update_UT_5k_flag == 0):
            time.sleep(kline_update_time)
        
        while(kline_bot_5m(600)):
            time.sleep(kline_update_time)
        
        print(time_day,now_time(),'前根5分收K價位為:',last_5k_close,'目前最高本金:',record_USDT,'目前下單金額:',round(order_USDT,4),'目前總損益:',round(benefit,2))

#        twoSignal_2_percent(last_5k_close)
#        twoSignal_3_percent(last_5k_close)
#        twoSignal_4_percent(last_5k_close)
        twoSignal_ema5_continue_5k()
        
        
        HF_stoploss = round((last_5k_close * 0.01),2)
        check_red_black_kline_continue_status(5)
#        twoSignal_continue_ema_3k(last_5k_close)
#        twoSignal_05_stop_profit_continue_3K()
        ChandeliersExit(22,1.85,1,5)
        UT_Bot_Alerts(5)

#        twoSignal_sellout_position() #判斷是否超過多空單支撐點
        Csss_5k_Supertrend = SuperTrend(UT_5_pd_data,10,3)
        
        EMA5_5k = EMA(UT_5_pd_data,5)
        EMA20_5k = EMA(UT_5_pd_data,20)
        EMA60_5k = EMA(UT_5_pd_data,60)
        EMA120_5k = EMA(UT_5_pd_data,120)
        EMA169_5k = EMA(UT_5_pd_data,169)
        EMA200_5k = EMA(UT_5_pd_data,200)
        EMA240_5k = EMA(UT_5_pd_data,240)
        EMA_5k_list = [EMA20_5k, EMA60_5k, EMA120_5k, EMA169_5k, EMA200_5k, EMA240_5k]
        
        P1P_EMA120_5k_p1p = round(EMA120_5k + (lastprice * P1P_Boundary_percent),2)
        P1P_EMA120_5k_m1p = round(EMA120_5k - (lastprice * P1P_Boundary_percent),2)
        P2P_EMA120_5k_p1p = round(EMA120_5k + (lastprice * P2P_Boundary_percent),2)
        P2P_EMA120_5k_m1p = round(EMA120_5k - (lastprice * P2P_Boundary_percent),2)

#        print('RB_TaxRate:',RB_TaxRate,' RB_Total_TaxRate:',RB_Total_TaxRate)
#        print('RB_over_x_percent_flag:',RB_over_x_percent_flag, 'HF_last_2_5k_close:', HF_last_2_5k_close)
#        print('HF_last_2_5k_high:', HF_last_2_5k_high, 'HF_last_2_5k_low:', HF_last_2_5k_low)
#        print('5k_EMA5:',EMA5_5k) #, '  ,5k_EMA60:',EMA60_5k, '  ,5k_EMA120:',EMA120_5k)
#        print('5k_EMA20:',EMA20_5k, '  ,5k_EMA60:',EMA60_5k, '  ,5k_EMA120:',EMA120_5k)
#        print('5k_EMA169:',EMA169_5k, '  ,5k_EMA200:',EMA200_5k, '  ,5k_EMA240:',EMA240_5k)
#        print('5k_EMA5:',EMA5_5k, '  ,5k_EMA120:',EMA120_5k, '  ,5k_EMA240:',EMA240_5k)
#        print('EMA List(5k):',EMA_5k_list,' 最大:',max(EMA_5k_list),' 最小:',min(EMA_5k_list))
#        print('P1P_EMA120_5k_m1p:',P1P_EMA120_5k_m1p,' P1P_EMA120_5k_p1p:',P1P_EMA120_5k_p1p,' P1P_go_return:',P1P_go_return)
#        print('P2P_EMA120_5k_m1p:',P2P_EMA120_5k_m1p,' P2P_EMA120_5k_p1p:',P2P_EMA120_5k_p1p)
#        print('len(hold_buy_set):',len(hold_buy_set),' len(hold_sell_set):',len(hold_sell_set),' RB_close_120ma:',RB_close_120ma)
        
        if bet_5k == 1:
            
            if len(hold_buy_set) > 0 or len(hold_sell_set) > 0 and show_tax == 1:
                
                print('目前出場總手續費為:',(2*RB_Total_TaxRate),end = '') 
                if len(hold_buy_set) > 0:
                    print(' ,多單收益為:',round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4),end = '') 
                    print(' ,總收益為:',round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4) - (2*RB_Total_TaxRate)) 
                if len(hold_sell_set) > 0:
                    print(' ,空單收益為:',round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4),end = '') 
                    print(' ,總收益為:',round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)- (2*RB_Total_TaxRate)) 
                

            
            if last_5k_close >= EMA120_5k :
                
                P1P_upper_120ma = 1
                P1P_below_120ma = 0
#                print('目前收K超過120ma')
                
                
            elif last_5k_close < EMA120_5k :
                
                P1P_upper_120ma = 0
                P1P_below_120ma = 1
#                print('目前收K低於120ma')
                
            
            if last_5k_high >= P1P_EMA120_5k_p1p:
                P1P_above_120ma_p = 1
                P1P_under_120ma_p = 0
            else:
                P1P_above_120ma_p = 0
                P1P_under_120ma_p = 1
                
            if last_5k_low <= P1P_EMA120_5k_m1p:
                P1P_above_120ma_m = 0
                P1P_under_120ma_m = 1
            else:
                P1P_above_120ma_m = 1
                P1P_under_120ma_m = 0
                

            print('5k')
#            print('   UT_Buy:',UT_5k_Buy,end = '')
#            print(' ,UT_Sell:',UT_5k_Sell,end = '')
#            print(' ,CE_Buy:',CE_5k_Buy,end = '')
#            print(' ,CE_Sell:',CE_5k_Sell,end = '')
#            print('   sign_now(買賣訊號) = ',sign_now,' ,sign_way = ',sign_way,end = '')
#            print('   wait2touch_120ma = ',wait2touch_120ma,' ,ceut_shoot_flag = ',ceut_shoot_flag)
            if CEUT_buy_count > 0 or CEUT_sell_count > 0:
                print('   CEUT_buy_count = ',CEUT_buy_count,' ,CEUT_sell_count = ',CEUT_sell_count, ' ,twoSingal_last_signal = ',twoSingal_last_signal) 
            if twoSignal_05percent_flag > 0:
                print('   twoSignal_05percent_flag =',twoSignal_05percent_flag)
            if twoSignal_4percent_flag > 0:
                print('   目前獲利大於4%')
            if twoSignal_3percent_flag > 0:
                print('   目前獲利大於3%') 
            if twoSignal_2percent_flag > 0:
                print('   目前獲利大於2%') 
#            print('   Grid_raise_order:',Grid_raise_order,' ,Grid_last_order_way:',Grid_last_order_way,end = '')
#            print(' ,Grid_4percent_flag:',Grid_4percent_flag,' ,Grid_1percent_return_flag:',Grid_1percent_return_flag)
#            print('   Grid_total_sellout_flag:',Grid_total_sellout_flag,' ,Grid_total_sellout_high:',Grid_total_sellout_high,end = '')
#            print(' ,Grid_total_sellout_low:',Grid_total_sellout_low)
#            print('   Grid_return_position:',Grid_return_position,' ,Grid_final_return_position:',Grid_final_return_position)

            print('')

            '''
            進場:
            高於UT且連續三根紅K大於ema5進場多 , 低於UT且連續三根黑K小於ema5進場空

            出場
            多單低於UT且連續三根黑K或是連續三根K棒低於ema5
            空單高於UT且連續三根紅K或是連續三根K棒高於ema5
            '''

            if init == 1:
                print('longStop(綠):',last_longStop_position,'  shortStop(紅):',last_shortStop_position,'  UT:',last_UT_position)
                print('EMA 5: ',)

            print('')
            _longstop_updown_continue()
            _3k_continue()
            _UT_updown()
            
            print('')
            print('')

            if  longstop_up >= 3 :

                print('連續三根在綠線之上,longstop_up =',longstop_up)
                
                if _3k_continue() == 1:

                    if twoSignal_ema5_continue_5k_up >= 3 and _UT_updown() == 1:
    
                        if len(hold_buy_set) == 0 and len(hold_sell_set) == 0:
                                
                            binance_buy_market_order(client,order_USDT*leverage/lastprice)
                                
                            stop_loss_set.append(lastprice - round(lastprice * 0.012,2))
    
                            print('停損設在:',stop_loss_set[len(stop_loss_set)-1])
                            binance_buy_stop_market()
                            hold_buy_set.append(lastprice)
                            hold_set_average()
                            CEUT_sell_count = 0
                            
                            print('     ------> sell_count 歸 0 :',CEUT_sell_count)
                            
                            print('               ------> 進場多',now_time())


                        elif len(hold_buy_set) > 0 and len(hold_sell_set) == 0:

                            print('            ------> 在綠線UT之上連收三根紅K,己有多單,  不動作',now_time())
                            
                        elif len(hold_buy_set) == 0 and len(hold_sell_set) > 0:
                               
                            
                            binance_close_position('BUY')
                            print('            ------> 連續收三根紅K,空單先平倉',now_time())
                            binance_cancel_all_futures_order(client)
                            
        
                            binance_buy_market_order(client,order_USDT*leverage/lastprice)
                            stop_loss_set.append(lastprice - round(lastprice * 0.012,2))
                            
                            print('停損設在:',stop_loss_set[len(stop_loss_set)-1])
                            binance_buy_stop_market()
                            hold_buy_set.append(lastprice)
                            hold_set_average()
                            CEUT_sell_count = 0
                            
                            print('     ------> sell_count 歸 0 :',CEUT_sell_count)
                            
                            print('               ------> 反手,進場多',now_time())
    
    
                    elif twoSignal_ema5_continue_5k_up >= 3 and _UT_updown() == -1:
    
                        if len(hold_buy_set) == 0 and len(hold_sell_set) > 0:
                               
                            
                            binance_close_position('BUY')
                            print('            ------> 未站上UT,空單先平倉',now_time())
                            binance_cancel_all_futures_order(client)
                            CEUT_sell_count = 0
                            
                            print('     ------> sell_count 歸 0 :',CEUT_sell_count)
                            
                            print('               ------> 等待進場',now_time())

                

                    

            elif longstop_down >= 3:

                print('連續三根在綠線之上,longstop_down =',longstop_down)

                if _3k_continue() == -1:
                
                    if twoSignal_ema5_continue_5k_down >= 3 and _UT_updown() == -1:
    
                        if len(hold_buy_set) == 0 and len(hold_sell_set) == 0:
                               
                            binance_sell_market_order(client,order_USDT*leverage/lastprice)
                            
                            stop_loss_set.append(lastprice + round(lastprice * 0.012,2))
    
                            
                            print('停損設在:',stop_loss_set[len(stop_loss_set)-1])
                            
                            binance_sell_stop_market()
                            hold_sell_set.append(lastprice)
                            hold_set_average()
                            CEUT_buy_count = 0
                            
                            print('     ------> buy_count 歸 0 :',CEUT_buy_count)
                            
                            print('               ------> 進場空',now_time())

                        elif len(hold_buy_set) == 0 and len(hold_sell_set) > 0:

                            print('            ------> 在綠線UT之下連收三根黑K,己有空單,  不動作',now_time())    
    
                        elif len(hold_buy_set) > 0 and len(hold_sell_set) == 0:
    
                            binance_close_position('SELL')
                            print('            ------> 連續收三根黑K,多單先平倉',now_time())
                            binance_cancel_all_futures_order(client)
    
                            binance_sell_market_order(client,order_USDT*leverage/lastprice)
                            stop_loss_set.append(lastprice + round(lastprice * 0.012,2))
                            
                            print('停損設在:',stop_loss_set[len(stop_loss_set)-1])
                            
                            binance_sell_stop_market()
                            hold_sell_set.append(lastprice)
                            hold_set_average()
                            CEUT_buy_count = 0
                            
                            print('     ------> buy_count 歸 0 :',CEUT_buy_count)
                            
                            print('               ------> 反手進場空',now_time())
    
    
                    elif twoSignal_ema5_continue_5k_down >= 3 and _UT_updown() == 1:

                        if len(hold_buy_set) > 0 and len(hold_sell_set) == 0:
    
                            binance_close_position('SELL')
                            print('            ------> 未收破UT,多單先平倉',now_time())
                            binance_cancel_all_futures_order(client)
                            CEUT_buy_count = 0
                            
                            print('     ------> buy_count 歸 0 :',CEUT_buy_count)
                            
                            print('               ------> 等待進場',now_time())
                        
                        

            
                        
                
#        update_5k_flag = 0

        '''
        print('')
        print('buy_already:',buy_already,'   sell_already:',sell_already,'   touch_onetime:',touch_onetime ,'   touch_UTST_area_flag:',touch_UTST_area_flag)
        print('buy_5k_already:',buy_5k_already,'   sell_5k_already:',sell_5k_already,'   HF_EMA120_5k_check_value:',HF_EMA120_5k_check_value ,'   HF_EMA120_15k_check_value:',HF_EMA120_15k_check_value)
        print('RB_buy_count:',RB_buy_count,'   RB_sell_count:',RB_sell_count)
        print('red_5k_continue:',red_5k_continue,'   black_5k_continue:',black_5k_continue,end = '')
        print('   red_15k_continue:',red_15k_continue,'   black_15k_continue:',black_15k_continue)
        print('RB_red_continue:',RB_red_continue,'   RB_black_continue:',RB_black_continue)
        
        '''
        
#        config_reload()
#        update_stoploss()
        hold_set_average()
        get_av_balance(client, time)
        save_context()
#        sellout_bound = round(lastprice * sellout_percent)

        if len(hold_buy_set) > 0 and len(targetSingal_buy_high) > 0 : 
            
            print('')
            print('目前為[多單],最後進場位置在:',hold_buy_set[len(hold_buy_set)-1],end = '')
            print(', 平均價格:',average_hold_buy,end = '')
            print(', 最後進場時間:',buy_time)
#            if twoSignal_05percent_flag == 0:
#                if len(targetSingal_buy_high) > 0:
#                    print('雙空訊號止損反轉點:[',check_twoSignal_high_low_position('low',max(targetSingal_buy_high)),']',end = '')
#                if len(save_buy_K_low_between_two_signal) > 0:
#                    print(' ,最初雙多訊號止損點:[',min(save_buy_K_low_between_two_signal),']') 
            print('停損位置:',stop_loss_set[len(stop_loss_set)-1])
            print('')
            
            print('目前多單獲利:',round((lastprice - average_hold_buy),4),'*',len(hold_buy_set),'塊ETH, ',end = '')
            buy_benefit = round((order_USDT*len(hold_buy_set)*leverage/average_hold_buy)*(lastprice - average_hold_buy),4)       
            print(buy_benefit,'塊USDT',end = '')
            
            
            
            
        if len(hold_sell_set) > 0 and len(targetSingal_sell_low) > 0:
            
            print('')
            print('目前為[空單],最後進場位置在:',hold_sell_set[len(hold_sell_set)-1],end = '')
            print(', 平均價格:',average_hold_sell,end = '')
            print(', 最後進場時間:',buy_time)
#            if twoSignal_05percent_flag == 0:
#                if len(targetSingal_sell_low) > 0:
#                    print('雙多訊號止損反轉點:[',check_twoSignal_high_low_position('high',min(targetSingal_sell_low)),']',end = '')
#                if len(save_sell_K_high_between_two_signal) > 0:
#                    print(' ,最初雙空訊號止損點:[',max(save_sell_K_high_between_two_signal),']')
            print('停損位置:',stop_loss_set[len(stop_loss_set)-1])
            print('')
            
            print('目前空單獲利:',round((average_hold_sell - lastprice),4),'*',len(hold_sell_set),'塊ETH, ',end = '')
            sell_benefit = round((order_USDT*len(hold_sell_set)*leverage/average_hold_sell)*(average_hold_sell - lastprice),4)
            print(sell_benefit,'塊USDT',end = '')
            
        
        
        if sellout_25_flag > 0:
            print('己出場',sellout_25_flag,'次')
        print('')
        print('連續虧損次數:',stoploss_time)
        print('獲利:',round(record_profit,4),end = '')
        print('(',round(record_profit/record_USDT*100,2),'%)',' ,網格獲利次數:',Grid_moving_sellout_time)
        print('虧損:',round(record_loss,4),end = '')
        print('(',round(record_loss/record_USDT*100,2),'%)')
        print('本次最大虧損:',round(RB_max_loss_percent,2),end = '')
        print('(',round(RB_max_loss_percent/record_USDT*100,2),'%)')
        print('未實現獲利:',round(ur_balance,4),'錢包總餘額:',round(mg_balance,2),'+(',contract_balance_buffer,')','目前最高本金:',record_USDT,end = '')
        print('剩餘保留資金:',round(buffer_USDT,2))
        
        if mg_balance > record_USDT:
            print('目前獲利: +',round((mg_balance/record_USDT-1)*100,2),'%')
        elif mg_balance < record_USDT:
            print('目前獲利: -',round((1-mg_balance/record_USDT)*100,2),'%')

        
        if round(ur_balance,4) > 0 and 0:
            
            if round(ur_balance,4)/record_USDT > 0.1:
                if len(hold_buy_set) > len(hold_sell_set):
                    binance_close_position('SELL')
                    print('多單獲利超過20%,全部平倉')
                elif len(hold_buy_set) < len(hold_sell_set):
                    binance_close_position('BUY')
                    print('空單獲利超過20%,全部平倉')


        
        
        write_to_config("config.ini", save_config_txt)    
        prev_5k_Supertrend = Csss_5k_Supertrend    
        change_k_flag = 0
        
#        t_stoploss.join()
        
        #print('change_k_flag_end:',change_k_flag) 
        print('')
        time.sleep(0.1)

#    if bet_5k == 1:    

#        shoot_trigger(lastprice,5)
#        total_sellout(lastprice,5)
        
#    elif bet_15k == 1:
        
#        shoot_trigger(lastprice,15)
#        total_sellout(lastprice,15)
    

def process_message(msg): #callback function
    global ETH_queue
    
    ETH_queue.append(float(msg['p']))    
    
    
    
client = Client(api_key = api_key , api_secret = api_secret)

print('start_str_1h:',start_str_1h)
print('interval_data_1h:',interval_data_1h)

# Get data from Binance
pd_data = pd.DataFrame(client.futures_historical_klines(symbol = symbol , start_str = start_str, interval = interval_data))
pd_data.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'qav','num_trades',
                     'taker_base_vol', 'taker_quote_vol', 'is_best_match']

UT_5_pd_data = pd.DataFrame(client.futures_historical_klines(symbol = symbol , start_str = start_str, interval = interval_data))
UT_5_pd_data.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'qav','num_trades',
                     'taker_base_vol', 'taker_quote_vol', 'is_best_match']

UT_15_pd_data = pd.DataFrame(client.futures_historical_klines(symbol = symbol , start_str = start_str_1h, interval = interval_data_1h))
UT_15_pd_data.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'qav','num_trades',
                     'taker_base_vol', 'taker_quote_vol', 'is_best_match']


binance_websocket_api_manager = BinanceWebSocketApiManager(exchange="binance.com-futures")
binance_websocket_api_manager.create_stream(['aggTrade'], [coin_symbol])




    
def strategy_start():
    
    print('strategy thread start')
    while True:
        
        try:
            if len(ETH_queue)>0 :
                go(client)
                pass

        except Exception as e:
            print(f'(go)錯誤訊息: {e}')
            if str(e) == 'APIError(code=-2013): Order does not exist.':
                print('Order does not exist.')
                
        time.sleep(0.001)
                
def stoploss_start():
    
    print('')
    print('stoploss thread start')
    
    while True:
        
        try:
            if len(Thread_queue)>0 :
                stoploss_and_sellout_thread()

        except Exception as e:
            print(f'(thread_)錯誤訊息: {e}')
            if str(e) == 'APIError(code=-2013): Order does not exist.':
                print('Order does not exist.')
                
        time.sleep(0.001)

        
update_UT_5k_flag = 1
update_UT_15k_flag = 1
def update_history_UT_5k():
    
    global update_UT_5k_flag
    
    print('')
    print('UT_5 thread start')
    
    while True:
        
#        print('UT_5 thread proceeing')
#        print('update_UT_5k_flag:',update_UT_5k_flag)
#        print('datetime.now().minute % 5:',datetime.now().minute % 5)
#        print('datetime.now().second:',datetime.now().second)
        try:
            if (datetime.now().minute % 5) == 0 and datetime.now().second < 15 and update_UT_5k_flag == 0 :

#                print('UT_5 thread start in',now_time())
#                while(kline_UT_5m(1500)):
                while(kline_UT_5m(622)):
#                    print('UT 5k line updating....',now_time())
                    pass
                
                if init == 0:
                    UT_Bot_Alerts(5)
                
#                print('                                                                                        ')
#                print('thread UT 5k 己更新')

            if (datetime.now().minute % 5) == 4 and datetime.now().second > 50 and update_UT_5k_flag == 1 :
#                print('UT 5k line prepare updating....',now_time())
#                print('check_UT_5_pd_data_last:',check_UT_5_pd_data_last)
                update_UT_5k_flag = 0
                
        except Exception as e:
            print(f'(thread history_UT_5k )錯誤訊息: {e}')
            

        time.sleep(0.1)
    
def update_history_UT_15k():
    
    global update_UT_15k_flag
    
    print('')
    print('UT_15 thread start')
    
    while True:
        
#        print('UT_15 thread proceeing')
#        print('update_UT_5k_flag:',update_UT_5k_flag)
#        print('datetime.now().minute % 5:',datetime.now().minute % 5)
#        print('datetime.now().second:',datetime.now().second)
        try:
            if (datetime.now().minute % 15) == 0 and datetime.now().second < 15 and update_UT_15k_flag == 0 :

#                print('UT_15 thread start in',now_time())
#                while(kline_UT_15m(1500)):
                while(kline_UT_15m(499)):
#                    print('UT 15k line updating....',now_time())
                    pass
                
                if init == 0:
                    UT_Bot_Alerts(15)
                    
                print('                                                                                        ')
#                print('thread UT 15k 己更新')
                
            if (datetime.now().minute % 15) == 14 and datetime.now().second > 50 and update_UT_15k_flag == 1 :
#                print('UT 15k line prepare updating....',now_time())
#                print('check_UT_15_pd_data_last:',check_UT_15_pd_data_last)
                update_UT_15k_flag = 0
                
        except Exception as e:
            print(f'(thread history_UT_15k)錯誤訊息: {e}')
            

        time.sleep(0.1)

        
       

        
t_strategy = threading.Thread(target = strategy_start)     
t_stoploss = threading.Thread(target = stoploss_start)
t_UT_5k_update = threading.Thread(target = update_history_UT_5k)
t_UT_15k_update = threading.Thread(target = update_history_UT_15k)

stop = threading.Event()
stop.set()
                
t_strategy.start()    
t_stoploss.start()
t_UT_5k_update.start()
t_UT_15k_update.start() 





try:
    while True:
        
        
        stream = binance_websocket_api_manager.pop_stream_data_from_stream_buffer()
        if stream:
            jsonstream = json.loads(stream)
            data = jsonstream.get('data') 
            if data:
                ETH_queue.append(float(data['p']))
                Thread_queue.append(float(data['p']))
        
        
        time.sleep(0.001)

except:

    t_strategy.join()    
    t_stoploss.join()
    t_UT_5k_update.join()
    t_UT_15k_update.join() 
    print(f'(thread stop)')

